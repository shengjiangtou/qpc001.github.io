<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EpsilonJohn&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-15T03:32:01.391Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>EpsilonJohn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MSCKF-1-前端</title>
    <link href="http://yoursite.com/2020/06/15/MSCKF-1-%E5%89%8D%E7%AB%AF/"/>
    <id>http://yoursite.com/2020/06/15/MSCKF-1-%E5%89%8D%E7%AB%AF/</id>
    <published>2020-06-15T03:00:04.000Z</published>
    <updated>2020-06-15T03:32:01.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="msckf-1-前端">MSCKF-1-前端</h1><p><img src="/2020/06/15/MSCKF-1-%E5%89%8D%E7%AB%AF/2020-06-15-11-01-37.png"></p><p><img src="/2020/06/15/MSCKF-1-%E5%89%8D%E7%AB%AF/2020-06-15-11-02-37.png"></p><p><img src="/2020/06/15/MSCKF-1-%E5%89%8D%E7%AB%AF/2020-06-15-11-02-47.png"></p><p>开源代码：</p><p>https://github.com/KumarRobotics/msckf_vio</p><h1 id="前端解析">前端解析</h1><p><img src="/2020/06/15/MSCKF-1-%E5%89%8D%E7%AB%AF/2020-06-15-11-10-14.png"></p><p><img src="/2020/06/15/MSCKF-1-%E5%89%8D%E7%AB%AF/2020-06-15-11-10-24.png"></p><p><img src="/2020/06/15/MSCKF-1-%E5%89%8D%E7%AB%AF/2020-06-15-11-14-56.png"></p><p><img src="/2020/06/15/MSCKF-1-%E5%89%8D%E7%AB%AF/2020-06-15-11-14-42.png"></p><p><img src="/2020/06/15/MSCKF-1-%E5%89%8D%E7%AB%AF/2020-06-15-11-27-34.png"></p><p><img src="/2020/06/15/MSCKF-1-%E5%89%8D%E7%AB%AF/2020-06-15-11-28-45.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;msckf-1-前端&quot;&gt;MSCKF-1-前端&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/15/MSCKF-1-%E5%89%8D%E7%AB%AF/2020-06-15-11-01-37.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>VLP-16-说明书摘要</title>
    <link href="http://yoursite.com/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    <id>http://yoursite.com/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/</id>
    <published>2020-06-10T01:02:09.000Z</published>
    <updated>2020-06-16T07:59:25.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vlp-16-说明书摘要">1. VLP-16-说明书摘要</h1><h1 id="激光脉冲间隔">2. 激光脉冲间隔</h1><p><img src="/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/2020-06-10-09-03-11.png"></p><h1 id="数据量计算">3. 数据量计算</h1><p><img src="/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/2020-06-10-09-03-25.png"></p><p><img src="/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/2020-06-10-09-03-40.png"></p><h1 id="旋转速度与水平角分辨率的关系">4. 旋转速度与水平角分辨率的关系</h1><p><img src="/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/2020-06-10-09-04-48.png"></p><h2 id="计算公式">4.1. 计算公式</h2><p>因为传感器的发射时间固定在每次发射序列的55.296us，旋转的速度改变了传感器的角度分辨率</p><p><img src="/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/2020-06-10-09-05-54.png"></p><h1 id="激光数据与坐标系等信息">5. 激光数据与坐标系等信息</h1><p>激光点云数据的原点位于激光雷达底座中心轴上方<code>37.7mm</code></p><p><img src="/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/2020-06-10-09-11-53.png"></p><h2 id="线束id号与垂直角的关系">5.1. 线束ID号与垂直角的关系</h2><p><img src="/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/2020-06-10-09-14-35.png"></p><p><img src="/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/2020-06-10-09-14-47.png"></p><h1 id="关于时间戳">6. 关于时间戳</h1><p>当传感器启动时，它开始使用内部时间基准计算微秒。然而，传感器可以与UTC时间异步它的数据，因此您可以确定任何特定数据包中的每一束激光的确切发射时间</p><p>UTC同步需要GPS/INS接收器生成一个同步的<code>Pluse Per Second(PPS)</code>信号和一个<code>NMEA GPRMC</code>语句，GPRMC消息提供了UTC中的分钟和秒，直到同步后，传感器从<code>GPRMC</code>语句读取分钟和秒数，然后使用这些信息来设置传感器的时间戳为当前这个小时所过去的<code>毫秒数</code></p><h2 id="详细讨论">6.1. 详细讨论</h2><p>下面两个选项控制LIdar如何使用GPS数据</p><p><img src="/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/2020-06-10-10-32-40.png"></p><ul><li>第一控制选项确定传感器如何利用PPS信号(PPS)</li><li>第二个控制选项决定传感器如何利用(NMEA)语句中提供的时间戳(GPS)</li></ul><h2 id="lidar内部计时逻辑">6.2. LIDAR内部计时逻辑</h2><p>激光雷达内部维护一个计数器，它表示自最高小时(TOH)以来的微秒数。TOH计数基于内部振荡器递增，<strong>当传感器被提供一个有效的PPS信号，TOH计数被调整为每个PPS上升边，以将TOH与UTC时间对齐</strong></p><p>TOH由两个独立的计数器组成。一个计数器维护从小时的顶部开始的分和秒数，另一个计数器维护次秒计数(图G-2)</p><p><img src="/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/2020-06-10-10-38-12.png"></p><h2 id="pps-qualifier">6.3. PPS Qualifier</h2><h3 id="选项1require-gps-receiver-valid">6.3.1. 选项1：Require GPS Receiver Valid</h3><ul><li>如果设置为<code>ON</code>，那么传感器需要GPS接收器接收到有效的卫星的时候，才认为PPS有效，（此判定通过传感器接收到NMEA语句来决定）</li><li>如果设置为<code>OFF</code>，传感器同步其亚秒计数器的上升边缘的PPS信号，而不管GPS接收机卫星状态</li></ul><h3 id="选项2require-pps-lock">6.3.2. 选项2：Require PPS Lock</h3><p>该设置决定了传感器在调整内部亚秒计数器到该PPS信号的上升边缘之前确认PPS信号的方式</p><ul><li>如果设置为<code>ON</code>，传感器利用在（选项3）<code>Delay</code>的值来确定在同步它的内部亚秒计数器到一个PPS信号的上升边缘之前的PPS的有效性</li><li>如果设置为<code>OFF</code>，该传感器忽略（选项3）<code>Delay</code>的值，在PPS信号可能被认为有效之前，传感器使用2个周期的滚动窗口，然后被传感器用作时间参考。 关闭此选项相当于将延迟值设置为2</li></ul><h3 id="选项3delay">6.3.3. 选项3：Delay</h3><p>该参数允许用户延长传感器验证PPS所需的时间。单位是整数（秒）。可接受的值范围从0到65535。默认值是5秒</p><h2 id="gps-qualifier">6.4. GPS Qualifier</h2><p>这个设置决定了TOH计数器的分和秒组件是根据GPS接收器提供的时间戳进行调整，（即使用NMEA语句来调整）</p><h1 id="相位锁用于多激光雷达抗干扰">7. 相位锁（用于多激光雷达抗干扰）</h1><p>当使用多个彼此接近的传感器(例如安装在车辆顶部)时，传感器数据中可能会出现偶尔的干扰模式。Velodyne提供了发射控制，通过控制数据聚集的位置来最小化这种干扰。然后可以将传感器配置为忽略包含干扰的数据。</p><h2 id="phase-lock">7.1. Phase Lock</h2><p>要求有PPS信号并且是Locked状态，传感器使用PPS信号的上升沿作为0度参考时刻，然后传感器调整它的时间，使得它序列起始的锁相偏移由用户指定。</p><p><strong>举例</strong></p><p>假设用户输入<span class="math inline">\(35\deg(\alpha)\)</span>作为相位偏移，如下图红色箭头，红色箭头精确地表示了激光发射方向，此时传感器接收到PPS信号的上升边缘。</p><h3 id="setting-the-phase-lock">7.1.1. Setting the Phase Lock</h3><p>要启用相位锁定，在下图所示的相位锁定偏移量字段中输入所需的相位偏移量。</p><p>例如，如果所需的偏移量是270，则在偏移量字段中输入270。单击按钮上的相位锁定(根据需要)，然后单击右边的设置按钮</p><p><img src="/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/2020-06-10-11-18-29.png"></p><h2 id="应用场景">7.2. 应用场景</h2><p>当为两个或更多的传感器设置相位锁定偏移时，Velodyne建议将传感器配置为to fire at each other。这是最小化干扰的最佳配置，因为干扰的位置在用户控制之下。</p><p>下图显示两个传感器安装在一辆车上。安装在车辆左侧的传感器将其相位锁偏置设置为90，安装在车辆右侧的传感器锁相偏置设置为270，如红色箭头表示</p><p><img src="/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/2020-06-10-11-21-54.png"></p><p><img src="/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/2020-06-10-11-22-57.png"></p><p>在这两种情况下，两个传感器在彼此背后创建数据阴影，为了避免来自相反传感器的阻塞或反射造成的任何虚假数据，用户应该忽略在shadowed方位角范围内的任何数据，如下面的图H-5所示。</p><p><img src="/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/2020-06-10-11-24-28.png"></p><p>要做到这一点，你需要知道传感器的直径(见第93页的传感器规格)和传感器中心之间的距离</p><h1 id="关于水平扫描角度的设定">8. 关于水平扫描角度的设定</h1><p>默认Y轴正方向为0度，那如果想要从X轴负方向开始扫描，那么设定如下</p><p>START： 270度 END： 450度</p><h1 id="命令设置激光雷达的参数">9. 命令设置激光雷达的参数</h1><p>这里只列出几个，具体参见VLP-16说明书，第10章</p><h2 id="set-motor-rpm">9.1. Set Motor RPM</h2><p>Sets the RPM of the motor. Valid integer values range from 300 to 1200, in increments of 60. (If the RPM setting is not evenly divisible by 60, neither motor speed control nor phase lock functions will function properly.) For values 1 through 299, the sensor defaults back to 300 RPM. If a value of 0 or less is entered, the sensor motor powers down and the lasers are turned off, as leaving them on with the motor stopped would be an unsafe eye state. This has the same effect as setting the value for the Motor RPM in the Web Interface.</p><p>Command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --data “rpm=[<span class="built_in">integer</span>]” http://192.168.1.201/cgi/setting</span><br></pre></td></tr></table></figure><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --data “rpm&#x3D;600” http:&#x2F;&#x2F;192.168.1.201&#x2F;cgi&#x2F;setting</span><br></pre></td></tr></table></figure><h2 id="set-field-of-view">9.2. Set Field of View</h2><p>Sets the field of view (0° to 359°). Numbers outside this range are quietly ignored. This has the same effect as setting the FOV Start and FOV End values on the Web Interface.</p><p>Command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --data “[start]|[end]&#x3D;[integer]” http:&#x2F;&#x2F;192.168.1.201&#x2F;cgi&#x2F;setting&#x2F;fov</span><br></pre></td></tr></table></figure><p>Examples:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl --data &quot;start&#x3D;10&quot; http:&#x2F;&#x2F;192.168.1.201&#x2F;cgi&#x2F;setting&#x2F;fov</span><br><span class="line">curl --data &quot;end&#x3D;270&quot; http:&#x2F;&#x2F;192.168.1.201&#x2F;cgi&#x2F;setting&#x2F;fov</span><br></pre></td></tr></table></figure><h2 id="set-return-type-strongest-last-dual">9.3. Set Return Type (Strongest, Last, Dual)</h2><p>This command sets the return type (or mode) of the sensor. Choose one: Strongest, Last, and Dual. This has the same effect as selecting the Web Interface Return Type.</p><p>Command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --data “returns&#x3D;[Strongest]|[Last]|[Dual]” http:&#x2F;&#x2F;192.168.1.201&#x2F;cgi&#x2F;setting</span><br></pre></td></tr></table></figure><p>Examples:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl --data “returns&#x3D;Strongest” http:&#x2F;&#x2F;192.168.1.201&#x2F;cgi&#x2F;setting</span><br><span class="line">curl --data “returns&#x3D;Last” http:&#x2F;&#x2F;192.168.1.201&#x2F;cgi&#x2F;setting</span><br><span class="line">curl --data &quot;returns&#x3D;Dual&quot; http:&#x2F;&#x2F;192.168.1.201&#x2F;cgi&#x2F;setting</span><br></pre></td></tr></table></figure><h2 id="save-configuration">9.4. Save Configuration</h2><p>Saves the configuration so that the settings are persistent across power cycles. This is equivalent to clicking on the Save Configuration button under the Configuration tab in the Web Interface.</p><p>Command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --data “submit” http:&#x2F;&#x2F;192.168.1.201&#x2F;cgi&#x2F;save</span><br></pre></td></tr></table></figure><h2 id="reset-system">9.5. Reset System</h2><p>Resets the sensor. This command performs the same operation as pressing the Reset System button under the System tab in the Web Interface, or if you cycled power to the sensor.</p><p>Command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --data &quot;reset_system&quot; http:&#x2F;&#x2F;192.168.1.201&#x2F;cgi&#x2F;reset</span><br></pre></td></tr></table></figure><p>Example Response:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The system resets.</span><br></pre></td></tr></table></figure><hr><h1 id="loam代码中关于vlp16的细节">LOAM代码中关于VLP16的细节</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!lidar scan开始点的旋转角,atan2范围[-pi,+pi],计算旋转角时取负号是因为velodyne是顺时针旋转</span></span><br><span class="line"><span class="keyword">float</span> startOri = -<span class="built_in">atan2</span>(laserCloudIn.points[<span class="number">0</span>].y, laserCloudIn.points[<span class="number">0</span>].x);</span><br><span class="line"><span class="comment">//lidar scan结束点的旋转角，加2*pi使点云旋转周期为2*pi</span></span><br><span class="line"><span class="keyword">float</span> endOri = -<span class="built_in">atan2</span>(laserCloudIn.points[cloudSize - <span class="number">1</span>].y,</span><br><span class="line">        laserCloudIn.points[cloudSize - <span class="number">1</span>].x) + <span class="number">2</span> * M_PI;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束方位角与开始方位角差值控制在(PI,3*PI)范围，允许lidar不是一个圆周扫描</span></span><br><span class="line"><span class="comment">//正常情况下在这个范围内：pi &lt; endOri - startOri &lt; 3*pi，异常则修正</span></span><br><span class="line"><span class="keyword">if</span> (endOri - startOri &gt; <span class="number">3</span> * M_PI) &#123;</span><br><span class="line">    endOri -= <span class="number">2</span> * M_PI;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (endOri - startOri &lt; M_PI) &#123;</span><br><span class="line">    endOri += <span class="number">2</span> * M_PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据点的仰角，区分所在线束编号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//坐标轴交换，velodyne lidar的坐标系也转换到z轴向前，x轴向左的右手坐标系</span></span><br><span class="line"><span class="built_in">point</span>.x = laserCloudIn.points[i].y;</span><br><span class="line"><span class="built_in">point</span>.y = laserCloudIn.points[i].z;</span><br><span class="line"><span class="built_in">point</span>.z = laserCloudIn.points[i].x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算点的仰角(根据lidar文档垂直角计算公式),根据仰角排列激光线号，velodyne每两个scan之间间隔2度</span></span><br><span class="line"><span class="keyword">float</span> angle = <span class="built_in">atan</span>(<span class="built_in">point</span>.y / <span class="built_in">sqrt</span>(<span class="built_in">point</span>.x * <span class="built_in">point</span>.x + <span class="built_in">point</span>.z * <span class="built_in">point</span>.z)) * <span class="number">180</span> / M_PI;</span><br><span class="line"><span class="keyword">int</span> scanID;</span><br><span class="line"><span class="comment">//仰角四舍五入(加减0.5截断效果等于四舍五入)</span></span><br><span class="line"><span class="keyword">int</span> roundedAngle = <span class="keyword">int</span>(angle + (angle&lt;<span class="number">0.0</span>?<span class="number">-0.5</span>:+<span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">if</span> (roundedAngle &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    scanID = roundedAngle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    scanID = roundedAngle + (N_SCANS - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//过滤点，只挑选[-15度，+15度]范围内的点,scanID属于[0,15]</span></span><br><span class="line"><span class="keyword">if</span> (scanID &gt; (N_SCANS - <span class="number">1</span>) || scanID &lt; <span class="number">0</span> )&#123;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vlp-16-说明书摘要&quot;&gt;1. VLP-16-说明书摘要&lt;/h1&gt;
&lt;h1 id=&quot;激光脉冲间隔&quot;&gt;2. 激光脉冲间隔&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/10/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LOAM-论文阅读</title>
    <link href="http://yoursite.com/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2020-06-08T15:41:02.000Z</published>
    <updated>2020-06-28T02:11:52.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="loam-lidar-odometry-and-mapping-in-real-time">LOAM: Lidar Odometry and Mapping in Real-time</h1><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-09-08-37-08.png"></p><h1 id="摘要">摘要</h1><p>主要思想，通过两个算法来同时优化大量变量，其中一个是作为高频输出的里程计，另一个是以更低的固定频率运行的后端优化。结合这两种算法，该方法可以实现实时分析。该方法已通过大量的实验和KITTI测程基准进行了评价。结果表明，该方法可以达到最先进的离线批处理方法的水平</p><ul><li>由于此方法是为了在测程估计中最小化漂移，所以目前不涉及<code>Loop Closure</code></li></ul><h1 id="去畸变">去畸变</h1><p>如果扫描运动相对缓慢（扫描周期长），运动失真会很严重。</p><p>文献[13]提出了一种两步法来去除激光雷达的畸变</p><ul><li>使用速度来矫正（其他传感器提供速度，或者使用ICP等算法来估计速度）</li></ul><blockquote><p>Barfoot等人使用的一种方法是从激光强度返回中创建视觉目标，并在两帧图像之间匹配视觉上不同的特征[17]，以恢复地面车辆的运动[18]～[21]。其中，文献[18,19]把车辆的运动建模为恒速度模型。</p><p>[18]～[21]的方法涉及灰度图像的视觉特征，需要密集的点云，本文提出的方法<strong>在笛卡尔空间中提取和匹配几何特征，对云密度要求较低</strong></p></blockquote><h1 id="符号约定">符号约定</h1><p>作为本文的一个惯例，我们使用右大写字母来表示坐标系统，使用右下标<span class="math inline">\(k,k\in Z^+\)</span>来表示扫描，其中<span class="math inline">\(\mathcal{P}_k\)</span>表示在第k次扫描的点云。</p><p>定义两个坐标系描述如下</p><ul><li>激光雷达坐标系<span class="math inline">\(L\)</span>，原点是激光雷达中心，x轴指向左侧，y轴指向上，z轴指向前方。对于此坐标系下的一个点<span class="math inline">\(i,i \in \mathcal{P}_k\)</span>，可以记为<span class="math inline">\(X_{(k,i)}^L\)</span></li><li>世界坐标系<span class="math inline">\(W\)</span>，原点是激光雷达的初始位姿，此坐标系下的点，记为<span class="math inline">\(X_{(k,i)}^W\)</span></li></ul><h1 id="系统概述">系统概述</h1><h2 id="硬件">硬件</h2><p>采用180度视野范围，0.25度分辨率，40线的激光雷达<code>UTM-30LX</code></p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-09-23-23-08.png"></p><h2 id="软件系统">软件系统</h2><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-09-23-24-04.png"></p><ul><li><span class="math inline">\(\hat{\mathcal{P}}\)</span>作为一帧扫描所得到的点，在每一次扫描中，<span class="math inline">\(\hat{\mathcal{P}}\)</span>被配准到激光雷达坐标系中</li><li>然后<span class="math inline">\(P_k\)</span>使用两种算法来处理：<ul><li>首先是激光里程计，计算两帧扫描来估计激光雷达的相对运动，估计得到的运动反过来矫正<span class="math inline">\(\mathcal{P}_k\)</span>的畸变，这个算法运行的频率为10Hz。</li><li>里程计的输出作为建图模块的输入，以1Hz的频率将去畸变后的点云进行匹配和配准到地图上。最后，将两个算法的结果进行整合，以10Hz输出位姿变换矩阵。</li></ul></li></ul><h1 id="激光里程计">激光里程计</h1><h2 id="特征提取">特征提取</h2><p>选取点云中边缘上的点以及平面上的点。</p><ul><li>i： 点云<span class="math inline">\(\mathcal{P}_k\)</span>中的点</li><li>S： 同一帧扫描中与点i连续的点集</li></ul><p>定义如下函数来评估某个点的平滑度：</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-11-19-46-06.png"></p><ul><li>根据计算得到的<span class="math inline">\(c\)</span>值进行排序，具有最大c值的特征点被选中，作为边缘点</li><li>具有最小c值的点也选中，作为平面点</li></ul><p>为了将特征点均匀地分布在环境中，我们将一次扫描分成四个子区域,每个子区域能最多提供2个边缘点和4个平面点。只有当点i的c值比阈值大或者小的时候，才会被考虑作为边缘点或者平面点，另外还要求选择的特征点不超过子区域最大值。</p><p>在选择特征点时，我们希望避免重复选取：</p><ul><li>某个已选中的特征点的附近点</li><li>与激光束大致平行的平面上的点(如图4(a))</li></ul><p>这些点通常认为是不可靠的，同时，我们要避免在被遮挡的区域边界上的点，如下图4(b)，点A是激光雷达云中的边缘点，因为它连接的表面(虚线段)被另一个物体阻塞了。然而，如果激光雷达移动到另一个视点，被遮挡的区域就会发生变化，成为可观测的。</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-11-19-56-10.png"></p><p>如何处理：</p><p>为了避免前面提到的点被选择，使用点集<span class="math inline">\(\mathcal{S}\)</span>进行判断：</p><ul><li>点集<span class="math inline">\(\mathcal{S}\)</span>不形成与激光束平行的平面</li><li>点集<span class="math inline">\(\mathcal{S}\)</span>中<strong>没有任何点</strong>是(由于激光束方向的gap导致)与点i不连续的，并且比点i更加靠近激光雷达的</li></ul><p>！！！则点i才有可能被选中！！！</p><h3 id="小结">小结</h3><p>综上所述，特征点的选取：以最大c值为起点来选择边缘点，以c值最小值为起点来选择平面点，</p><ul><li>选择的边缘点或平面点不超过子区域的最大值</li><li>候选点i的附近点没有被选中</li><li>候选点i所在的 局部平面 不能与激光束方向平行，或者是被遮挡区域的边界点</li></ul><p>如下图5所示</p><ul><li>黄色：边缘点</li><li>红色：平面点</li></ul><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-11-20-10-53.png"></p><h2 id="查找特征点关联">查找特征点关联</h2><ul><li><span class="math inline">\(t_k\)</span>：第k帧扫描的起始时间</li><li><span class="math inline">\(\bar{\mathcal{P}}_k\)</span>：第k帧扫描重投影到第k+1帧扫描起始时刻的点云</li></ul><p>在每一帧扫描的结束时，在该帧扫描得到的点云<span class="math inline">\(\mathcal{P}_k\)</span>被重投影到时间戳为<span class="math inline">\(t_{k+1}\)</span>，如图6所示。在接下来的<span class="math inline">\(t_{k+1}\)</span>时刻的扫描中，<span class="math inline">\(\bar{\mathcal{P}}_k\)</span>与<span class="math inline">\(t_{k+1}\)</span>新扫描点云<span class="math inline">\(\mathcal{P}_{k+1}\)</span>一起用来估计激光雷达的运动。</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-11-20-18-20.png"></p><p>假设<span class="math inline">\(\bar{\mathcal{P}}_k\)</span>和<span class="math inline">\(\mathcal{P}_{k+1}\)</span>都可用，然后开始寻找两帧点云之间的关联。</p><p>对于点云<span class="math inline">\(\mathcal{P}_{k+1}\)</span>，先选出边缘点和平面点。</p><ul><li><span class="math inline">\(\mathcal{E}_{k+1}\)</span>：边缘点集合</li><li><span class="math inline">\(\mathcal{H}_{k+1}\)</span>：平面点集合</li></ul><p>注意，在扫描<span class="math inline">\(k+1\)</span>开始时，<span class="math inline">\(\mathcal{P}_{k+1}\)</span>是一个空的点集，在扫描过程中，随着接收到更多的点，该点数会增长。激光里程计连续地估计扫描中的6自由度的运动，同时<span class="math inline">\(\mathcal{P}_{k+1}\)</span>点数增加。</p><p><strong>在每次迭代中，使用当前的里程计位姿估计，将<span class="math inline">\(\mathcal{E}_{k+1}\)</span>和<span class="math inline">\(\mathcal{H}_{k+1}\)</span>投影到当前帧的扫描起始时刻，分别得到<span class="math inline">\(\bar{\mathcal{E}}_{k+1}\)</span>和<span class="math inline">\(\bar{\mathcal{H}}_{k+1}\)</span></strong></p><p>对于<span class="math inline">\(\bar{\mathcal{E}}_{k+1}\)</span>和<span class="math inline">\(\bar{\mathcal{H}}_{k+1}\)</span>中的每一个点，我们准备从点云<span class="math inline">\(\bar{\mathcal{P}}_k\)</span>中选择最近邻的点，注意：为了快速查找，点云<span class="math inline">\(\bar{\mathcal{P}}_k\)</span>以<code>3D-KD-tree</code>形式来储存</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-11-21-00-43.png"></p><h3 id="边缘线点的关联">边缘线点的关联</h3><p>图7(a)表示了寻找与边缘点对应的边缘线的过程，假设:</p><ul><li><span class="math inline">\(i\)</span>是<span class="math inline">\(\bar{\mathcal{E}}_{k+1}\)</span>中的点</li><li><span class="math inline">\(j\)</span>是在<span class="math inline">\(\bar{\mathcal{P}}_k\)</span>中与点<span class="math inline">\(i\)</span>最近邻的点（图中的橙色线上的点）</li><li><span class="math inline">\(l\)</span>是两个连续线束扫描中与点<span class="math inline">\(i\)</span>最近邻的点（图中的上下两条蓝色线束）</li><li>那么<span class="math inline">\((j,l)\)</span>表达了一条关于点<span class="math inline">\(i\)</span>的边缘线</li></ul><p>边缘线使用两个点来表示：</p><blockquote><p><span class="math inline">\((j,l)\)</span>形成了点i的关联，为了确认点<span class="math inline">\(j\)</span>和<span class="math inline">\(l\)</span>都是边缘点，我们基于平滑度计算公式来对局部平面的平滑度进行检查。在这里，特别要求<span class="math inline">\(j\)</span>和<span class="math inline">\(l\)</span>是来自<strong>不同线束</strong>的扫描，原因是考虑到一线束的扫描中，对于同一个边缘线不能超过1个点。（只有一个例外，即边缘线在扫描平面上，在这种情况下，边缘线会退化为扫描平面上的一条直线，线上的特征点不应该被首先提取）</p></blockquote><h3 id="平面点的关联">平面点的关联</h3><p>图7(b)展示了查找与平面点<span class="math inline">\(i\)</span>相关联的平面块的过程，假设</p><ul><li><span class="math inline">\(i\)</span>：<span class="math inline">\(\bar{\mathcal{H}}_{k+1}\)</span>中的点</li><li><span class="math inline">\(j\)</span>：在<span class="math inline">\(\bar{\mathcal{P}}_{k}\)</span>中关于点<span class="math inline">\(i\)</span>的最近邻点</li><li><span class="math inline">\(l\)</span>：在与点<span class="math inline">\(j\)</span>的同一线圈扫描中，另一个与点<span class="math inline">\(i\)</span>的最近邻点</li><li><span class="math inline">\(m\)</span>：在与点<span class="math inline">\(j\)</span>的相邻两线圈扫描中，与点<span class="math inline">\(i\)</span>的最近邻点</li></ul><p>平面块(planer patch)使用3个点来表示：</p><ol type="1"><li>在<span class="math inline">\(\bar{\mathcal{P}}_{k}\)</span>中查找关于点<span class="math inline">\(i\)</span>的最近邻点，记为<span class="math inline">\(j\)</span></li><li>在与点<span class="math inline">\(j\)</span>的同一线圈中，另一个与<span class="math inline">\(i\)</span>最近邻的点，记为<span class="math inline">\(l\)</span></li><li>在与点<span class="math inline">\(j\)</span>的相邻两线圈扫描中，找到与点<span class="math inline">\(i\)</span>的最近邻的点，记为<span class="math inline">\(m\)</span></li></ol><p>这样，保证了这3个点<span class="math inline">\((j,l,m)\)</span>不共线，为了确定<span class="math inline">\((j,l,m)\)</span>是否都是平面点，再次使用公式一来检查对应的平滑度。</p><h3 id="特征距离表达式">特征距离表达式</h3><p>这个特征距离作为目标函数的一部分，通过最小化目标函数，来求解出激光雷达的运动。</p><p>根据找到的特征点的对应关系，计算从特征点到对应特征关联的距离：</p><p><strong>边缘线特征距离</strong></p><p>对于每一个在边缘集合<span class="math inline">\(\bar{\mathcal{E}}_{k+1}\)</span>中的点，如果<span class="math inline">\((j,l)\)</span>是对应该点的边缘线，那么就可以计算特征距离：</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-16-09-11-25.png"></p><p>其中，</p><ul><li><span class="math inline">\(\bar{X}_{k+1,i}^L\)</span>是点<span class="math inline">\(i\)</span>在{L}中的坐标</li><li><span class="math inline">\(\bar{X}_{k,j}^L\)</span>是点<span class="math inline">\(j\)</span>在{L}中的坐标</li><li><span class="math inline">\(\bar{X}_{k,l}^L\)</span>是点<span class="math inline">\(l\)</span>在{L}中的坐标</li></ul><blockquote><p>公式原理： 叉乘计算出平行四边形面积 在除以长度，可以得到点到线的垂线距离</p></blockquote><p><strong>平面点特征距离</strong></p><p>对于在平面集合<span class="math inline">\(\bar{H}_{k+1}\)</span>中的点<span class="math inline">\(i\)</span>，如果<span class="math inline">\((j,l,m)\)</span>是对应的平面块，那么那么点<span class="math inline">\(i\)</span>到平面块<span class="math inline">\((j,l,m)\)</span>的距离为：</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-16-09-22-03.png"></p><p>其中，</p><ul><li><span class="math inline">\(\bar{X}_{k,m}^L\)</span>是点<span class="math inline">\(m\)</span>在{L}中的坐标</li></ul><h2 id="运动估计">运动估计</h2><p>在扫描过程中，假设激光雷达的运动以<strong>恒定的角速度</strong>和<strong>恒定的线速度</strong>进行（匀速模型）。</p><p>这种假设允许我们在一帧扫描中(a sweep)对每一个在不同时间接收到的点对应的激光雷达位姿进行线性插值得到。</p><p>假设：</p><ul><li><span class="math inline">\(t\)</span>: 当前时刻时间戳</li><li><span class="math inline">\(t_{k+1}\)</span>: 在第k+1帧扫描的起始时刻</li><li><span class="math inline">\(T_{k+1}^L\)</span>: 在时间段<span class="math inline">\([t_{k+1},t]\)</span>之间的激光雷达位姿变换<span class="math inline">\(T_{k+1}^L=[t_x,t_y,t_z,\theta_x,\theta_y,\theta_z]^T\)</span>(旋转部分遵循右手系)</li></ul><p>给定一个在<span class="math inline">\(\mathcal{P}_{k+1}\)</span>中的点<span class="math inline">\(i\)</span></p><ul><li><span class="math inline">\(t_i\)</span>为接收到点<span class="math inline">\(i\)</span>的对应时刻<span class="math inline">\((t_i \in [t_{k+1},t])\)</span></li><li><span class="math inline">\(T_{(k+1,i)}^L\)</span>为时间段<span class="math inline">\([t_{k+1},t_i]\)</span>之间的激光雷达位姿变换 <font color="red">===&gt;</font> 从<span class="math inline">\(t_i\)</span>时刻激光雷达坐标系转换到<span class="math inline">\(t_{k+1}\)</span>时刻的激光雷达坐标系的变换</li></ul><p>那么，<span class="math inline">\(T_{(k+1,i)}^L\)</span>可以通过对<span class="math inline">\(T_{k+1}^L\)</span>进行线性差值得到：</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-16-09-35-12.png"></p><p>回想一下:</p><ul><li><span class="math inline">\(\mathcal{E}_{k+1}\)</span>和<span class="math inline">\(\mathcal{H}_{k+1}\)</span>分别是从<span class="math inline">\(\mathcal{P}_{k+1}\)</span>提取出来的边缘点和平面点集合</li><li><span class="math inline">\(\tilde{\mathcal{E}}_{k+1}\)</span>和<span class="math inline">\(\tilde{\mathcal{H}}_{k+1}\)</span>是将上面的点集重投影回在第<span class="math inline">\(k+1\)</span>帧扫描的起始时刻的点集</li></ul><p>为了求解激光雷达的运动，我们需要建立</p><ul><li><span class="math inline">\(\mathcal{E}_{k+1}\)</span>和<span class="math inline">\(\tilde{\mathcal{E}}_{k+1}\)</span></li><li><span class="math inline">\(\mathcal{P}_{k+1}\)</span>和<span class="math inline">\(\tilde{\mathcal{H}}_{k+1}\)</span></li></ul><p>之间的几何关系。</p><p>使用公式(4)的变换，可以推导得到上述关系:</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-16-10-03-47.png"></p><p>其中，</p><ul><li><span class="math inline">\(X_{(k+1,i)}^L\)</span>是点<span class="math inline">\(i\)</span>投影到<span class="math inline">\(t_{k+1}\)</span>时刻下的激光雷达坐标系的坐标</li><li><span class="math inline">\(T_{(k+1,i)}^L(1:3)\)</span>表示从<span class="math inline">\(t_i\)</span>时刻激光雷达坐标系转换到<span class="math inline">\(t_{k+1}\)</span>时刻的激光雷达坐标系的平移量变换</li><li><span class="math inline">\(R\)</span>是使用罗德里格斯公式得到的旋转矩阵</li></ul><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-16-10-12-50.png"></p><p>上式中的<span class="math inline">\(\theta\)</span>为，表示旋转的量:</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-16-10-13-55.png"></p><p><span class="math inline">\(w\)</span>是单位向量，表示旋转的方向，<span class="math inline">\(\hat{w}\)</span>是关于向量<span class="math inline">\(w\)</span>的反对称矩阵:</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-16-10-15-18.png"></p><p>回想一下：公式(2),(3)计算了<span class="math inline">\(\tilde{\mathcal{E}}_{k+1}\)</span>和<span class="math inline">\(\tilde{\mathcal{H}}_{k+1}\)</span>中的点与其对应的特征关联之间的距离，</p><p>结合公式(2)和(4~8)，我们可以推导出集合<span class="math inline">\(\mathcal{E}_{k+1}\)</span>中的边缘点和其对应的特征关联之间的几何关系:</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-16-10-57-54.png"></p><p>同样的，结合公式(3)和(4~8)，有：</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-16-10-58-33.png"></p><p>最后，通过LM算法来求解激光雷达的运动：</p><p>对于在<span class="math inline">\(\mathcal{E}_{k+1}\)</span>和<span class="math inline">\(\mathcal{H}_{k+1}\)</span>中的每个点，都可生成如同式(9)和(10)的方程，通过遍历，可以得到一个非线性函数：</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-16-11-02-43.png"></p><p>其中，</p><ul><li><span class="math inline">\(f()\)</span>中的每一行与一个特征点相关联</li><li><span class="math inline">\(d\)</span>包含了对应的特征关联距离</li></ul><p>然后计算矩阵<span class="math inline">\(f()\)</span>关于<span class="math inline">\(T_{k+1}^L\)</span>的雅克比矩阵，即</p><p><span class="math display">\[  J=\frac{\partial f}{\partial T_{k+1}^L}\]</span></p><p>然后，式(11)可以通过以最小化<span class="math inline">\(d\)</span>为目标，使用非线性迭代来求解:</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-16-11-08-19.png"></p><p>(QPC: add)那么，每次迭代的增量方程应该是:</p><p><span class="math display">\[  (J^TJ+\lambda)dx=J^Td\]</span></p><p>其中</p><ul><li><span class="math inline">\(\lambda\)</span>是LM算法的参数</li></ul><h3 id="小结-1">小结</h3><p>激光里程计的算法，总结如下图</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-16-11-15-08.png"></p><h1 id="建图lidar-mapping">建图(LIDAR MAPPING)</h1><p>建图算法以低频率运行，每一圈扫描执行一次。在第k+1圈扫描的结束时刻，里程计模块生成去畸变后的点云<span class="math inline">\(\bar{P}_{k+1}\)</span>，同时还有激光雷达的相对位姿变换<span class="math inline">\(T_{k+1}^L\)</span>。</p><p>建图部分将去畸变后的点云<span class="math inline">\(\bar{P}_{k+1}\)</span>配准到世界坐标系<span class="math inline">\({W}\)</span>中，如下图8所示</p><p><img src="/2020/06/08/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-06-28-10-07-45.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;loam-lidar-odometry-and-mapping-in-real-time&quot;&gt;LOAM: Lidar Odometry and Mapping in Real-time&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/08/LOAM-%E8%A
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Review-3D-Lidar-Localization</title>
    <link href="http://yoursite.com/2020/06/02/Review-3D-Lidar-Localization/"/>
    <id>http://yoursite.com/2020/06/02/Review-3D-Lidar-Localization/</id>
    <published>2020-06-02T03:02:33.000Z</published>
    <updated>2020-06-02T07:14:08.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="d-激光雷达定位方法汇总">1. 3D-激光雷达定位方法汇总</h1><p>本次调查的目的是回顾和介绍与三维激光雷达定位相关的工作，比较文献中报道的不同结果，并讨论各自的优缺点。</p><p><img src="/2020/06/02/Review-3D-Lidar-Localization/2020-06-02-11-12-06.png"></p><h1 id="d-registration-based-methods">2. 3D Registration Based Methods</h1><p>通常与离线构建的地图结合使用，这些方法的优越性在于使用点云配准的方法。虽然这些方法非常精确，但当只依赖于激光雷达数据时，它们的速度太慢，无法实现实时处理。</p><p>点云配准主要用于两种情况 - 一是将激光扫描与局部地图进行配准 - 二是连续的激光扫描之间的配准，计算相对位姿</p><h2 id="icpiterative-closest-point">2.1. ICP(Iterative Closest Point)</h2><p>多年来，ICP算法一直是解决点云配准问题的标准。</p><p>通过以优化迭代的方式最小化目标点云和源点云之间的误差测量，来获得两组点云之间的相对变换关系。</p><p>其变体还有：</p><ul><li>point-to-line ICP</li><li>point-to-plane</li><li>Generalized ICP</li></ul><p>在最近的[50]中，提出了一种集成了激光雷达传感器物理知识并改进了ICP算法的测距法，采用了一种新颖的下采样和点匹配抑制方法：激光雷达扫描的下采样是使用一个正常协方差滤波器(NCF)完成的，该滤波器只保留精确正态点。</p><h2 id="ndt">2.2. NDT</h2><p>然而，ICP算法最终被3D正态分布变换(NDT)算法所超越[14], [51]。与ICP算法类似，对源点云和目标点云之间的变换矩阵进行迭代优化，不同的是，被最小化的误差不是两个点云的点对距离，而是首先将点云转换为概率密度函数(PDF)，然后基于预先计算的体素中点的平均值和协方差来计算。此PDF可与牛顿迭代法一起使用，以查找它们之间的空间转换。</p><h2 id="imls-slam">2.3. IMLS-SLAM</h2><p>在一个更经典的SLAM方法中，作者在[20]中提出了一个名为<code>IMLS-SLAM</code>的3步算法</p><ul><li>首先是动态对象删除，简化为扫描和小簇删除的聚类</li><li>第二步是采用基于每个点的可观察性的采样策略，以便对扫描进行降采样</li><li>然后最后是匹配步骤，其中使用Implicit移动最小二乘法(IMLS)表示</li></ul><h2 id="cls-slam">2.4. CLS-SLAM</h2><p>Collar Line Segments(CLS)结构是一种有用的预处理方法，它可以达到较高的精度：在[38]中，通过从邻近环的邻近点之间采样线段，可以从激光雷达扫描提取线狀点云，然后使用迭代方法对这些线狀点云进行对准：</p><ul><li>首先，计算生成的直线的中心点</li><li>然后，这些点被用来查找在连续扫描之间的转换，方法是，对目标点云和已有点云的线狀点云进行配准，其中两组线狀点云之间用中心点的距离来关联</li></ul><h2 id="dlo">2.5. DLO</h2><p>有时，降低激光雷达数据的维度也可以产生合理的结果，例如在[40]中，激光扫描被投影到带有占据栅格和高度值的2.5D网格地图中。这个网格映射相当于灰度图像，它用于基于图像测量误差来进行配准，就像通常对相机数据所做的那样。</p><h1 id="d-features-based-methods">3. 3D Features Based Methods</h1><p>灵感来源于流行的基于二维特征提取和匹配的方法，这些方法在三维空间中设计相关的特征，然后用于计算相对位移。这些方法的精度和实时性较好，但在处理机动粗糙和高速运动时，效果较差。这些方法可以被看作是稀疏方法，因为他们只使用在部分的激光雷达点云数据</p><p>针对非道路环境，[19]提出了并命名为CPFG-SLAM的方法，其灵感来自于ICP和NDT算法，并依赖于3D特征和概率网格地图。利用<code>网格中的最近邻</code>而不是<code>空间最近邻</code>点，可以更有效地将点云匹配并注册到网格地图中。期望最大化(EM)算法用于估计姿态，最终优化问题使用Levenberg-Marquardt算法求解。</p><p>其他定位方法尝试利用环境中存在的主要几何形状:在[21]和[22]中，平面提取算法与帧对帧技术相结合，以生成车辆的位姿估计</p><h2 id="loam">3.1. LOAM</h2><p>目前，在KITTI Odom排行榜上居领先位置，在[25]中提出的方法首先基于点的平滑度和遮挡度提取<code>平面</code>和<code>角点</code>特征。这些特征与后续扫描的点的patch匹配，然后使用Levenberg-Marquardt方法求解激光雷达的运动</p><p>LOAM系列文献</p><ul><li>[25] J. Zhang and S. Singh, “Loam: Lidar odometry and mapping in realtime.”</li><li>[26] T. Shan and B. Englot, “Lego-loam: Lightweight and groundoptimized lidar odometry and mapping on variable terrain,” in 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS). IEEE, 2018, pp. 4758–4765.</li><li>[27] X. Ji, L. Zuo, C. Zhang, and Y. Liu, “Lloam: Lidar odometry and mapping with loop-closure detection based correction,” in 2019 IEEE International Conference on Mechatronics and Automation (ICMA), Aug 2019, pp. 2475–2480.</li><li>[28] J. Lin and F. Zhang, “A fast, complete, point cloud based loop closure for lidar odometry and mapping,” 09 2019</li></ul><h1 id="d-deep-learning-based-methods">4. 3D Deep Learning Based Methods</h1><p>最近，使用Deep Learning解决定位问题的做法越来越流行。二维相机图像首先被用来尝试和预测一对目标[5]、[6]、[7]、[8]之间的里程数，其结果或多或少是可以接受的，但仍然没有超过目前的技术水平。最近，更多的工作已经探索使用激光雷达，而结果似乎更有希望。</p><p>深度学习方法：</p><ul><li>端到段的深度学习方法使用原始点云作为输入，直接预测车辆的位移作为输出</li><li>使用深度学习替换传统配准流程中的某个子模块</li></ul><h2 id="端到端">4.1. 端到端</h2><p>[13]的想法是，尝试把这个挑战带回到图像域，而不是试图在3D pointcloud 中直接解决它，为了简化输入到网络中的数据，激光雷达扫描的点云首先投影到2D空间，从而产生<code>全景深图像</code>，然后输入到一个简单的2分支卷积网络，试图恢复出车辆在两个输入帧之间的位移和方向变化。结果表明，与目前的研究水平相比，作者的研究成果低于平均水平</p><h3 id="deeppco">4.1.1. DeepPCO</h3><p>全景深度图像（Panoramic depth images）、是激光雷达数据的一种常用表示方法，另一种利用到全景深度图像的方法是DeepPCO [17]，投影的激光雷达帧被送入一个2branch的网络，其中第一个分支预测车辆的平移，而第二个分支预测车辆的旋转。</p><h3 id="deeplo">4.1.2. Deeplo</h3><p>另一种尝试简化投射到二维空间的输入数据的方法是[18]中提出的方法：激光雷达帧投影使用球形坐标系系统生成两个新的二维表示：</p><ul><li>a vertex map (representing the location (x,y,z) of each point)</li><li>a normal map (representing the values of the normals of each point)</li></ul><p>提出的网络由残差块组成，有两个主要分支：</p><ul><li>第一个名为VertexNet，它将顶点map作为输入，并用于预测后续帧之间的平移</li><li>第二个分支名为NormalNet，以normal map作为输入，用于预测两个后续帧之间的旋转</li></ul><p>为了以端到端的方式训练完整的网络，作者提出了两种不同的训练方案，基于标记数据的可用性，采用两种不同的损失函数：</p><ul><li>首先是一个经典的有监督的损失，将标记数据与网络预测进行比较，以优化网络的权重</li><li>其次是无监督损失，即不需要标签数据，使用ICP算法引导网络进行正确的运动预测</li></ul><h2 id="基于3d场景分割">4.2. 基于3D场景分割</h2><p><img src="/2020/06/02/Review-3D-Lidar-Localization/2020-06-02-14-30-38.png"> <img src="/2020/06/02/Review-3D-Lidar-Localization/2020-06-02-14-30-56.png"></p><p>在[32]、[31]、[33]、[34]等一系列最终形成最终的三维分段方法，[35]的论文中，作者探索了如何利用简单的卷积网络从点云中高效提取和编码段，希望能解决定位和建图相关的任务。</p><p>该方法的主要特点是：数据驱动的3D Segment 描述符，采用由卷积层和全连通层组成的网络来提取。</p><p>这个描述符提取网络使用两部分组成的loss function来训练：</p><ul><li>分类损失</li><li>重建损失</li></ul><p>最后利用k-NN算法找到提取的分段及其对应的候选，这使得解决localization任务成为可能。</p><p>注意，3D SegMap描述符是一个通用描述符，也可以用于解决其他任务如对象分类</p><h3 id="lo-net-remove-dynamic-obj">4.2.1. LO-Net (Remove Dynamic Obj)</h3><p>当试图还原两帧之间的运动时，前面讨论的大多数方法将不可避免地受到场景中的动态对象(汽车、行人等)的影响，remove这些动态的对象可以提高里程的精度。但是，在有监督下进行检测并从场景中删除动态对象会增加复杂性，从而导致更高的处理时间和不稳定的结果。</p><p>为了以无监督的方式解决这一问题，[37]的作者提出了训练一个用于动态mask预测任务的encoder-decoder branch，这是通过优化<code>几何一致性损失函数</code>来实现的。</p><p>整个网络(名为LO-Net)可以结合几何一致性损失、里程回归损失和交叉熵损失以端到端的方式进行训练，用于正则化目的</p><h2 id="模块替换">4.3. 模块替换</h2><p>除了使用直接Lidar Frames直接学习定位车辆的模型，其他的方法尝试学习经典Pipline中的误差模型等。换句话说，可以使用深度学习的方法来纠正里程测量值，从而得到功能强大且灵活的可插拔模块</p><h3 id="l3-net">4.3.1. L3-Net</h3><p>在[39]的作者提出了学习偏差校正项，旨在改进以激光雷达数据为输入的经典状态估计器的结果。采用高斯过程模型对6个odometry误差进行了相互独立的建模，精心选择的输入参数集中在误差影响最大的3个自由度</p><p>在[41],提出了一种更高级的方法叫L3-Net，与bias correction 主题相关，作者提出一个网络，目的是学习传统定位系统与真值之间的残差，而不是直接预测两帧之间的变换矩阵。</p><p>相关的特征首先被提取并输入到一个<code>miniPointNet</code>中，以生成它们的相关特征描述符，然后在解空间(x,y,z)构造一个cost volume，并使用3D卷积神经网络进行调整。</p><p>此外，一个RNN branch被添加到网络结构，以保证位移预测的平滑性</p><h3 id="deep-icpnew端到端">4.3.2. Deep-ICP(NEW，端到端)</h3><p>同样的作者在[42]，[43]中提出了L3-Net的一个更完整和更一般的变体，并命名为<code>DeepICP</code>，这里，使用pointnet++提取特征，然后使用权重层过滤，只保留最相关的，与前面的方法类似，特征描述符使用一个<code>miniPointNet</code>结构计算，然后输入到相应的点生成层(point generation layer)，在目标点云中生成相应的关键点。为了恢复出相对变换的最终值，结合两个损失函数，希望对局部相似性和全局几何约束进行编码。</p><h3 id="cae-lo">4.3.3. CAE-LO</h3><p>最近，提出了一种新的解决方案CAE-LO，其中：</p><ul><li>使用了一个无监督卷积自动编码器，以多尺度的方式从激光雷达的球形投影中提取特征</li><li>一个自动编码器用于生成特征描述符，用来进行基于RANSAC的帧与帧之间的对应点的匹配</li><li>如果知道了两组点云之间的点对匹配关系，则可以使用ICP进行解析求解</li></ul><h3 id="locnet看看">4.3.4. Locnet（看看）</h3><p>在[23]中，再次尝试简化输入的数据，提出了一种基于点云环状分布的手工旋转不变表示方法(RIR)。作者称，正是由于这种表示方法，全局定位问题被重新表述为 an identity verification problem。</p><p>这个问题通过使用siamese网络称LocNet来解决，它以2个后续的RIR作为输入，目标是优化一个对比损失函数[61]，LocNet的输出是一个降维特征向量，在后续的全SLAM管道中使用，其中使用MCL[62]和ICP算法求解最终的粗到细的变换。</p><h3 id="lorax">4.3.5. LORAX</h3><p>在[29]中，提出了LORAX算法，这种方法引入了<code>超点</code>的概念，超点是位于球内的点的子集，它描述了一个局部平面，被投影到2D空间以形成2D深度maps。这些depth maps然后使用一系列的测试进行过滤，只留下相关的超点，然后使用PCA和深度自动编码器对其进行编码。然后根据欧氏距离对特征候选之间进行匹配，然后进行粗配准步骤，其中使用了涉及RANSAC的迭代方法。最后，为了对配准步骤的结果进行微调，采用了ICP算法来提高整个配准过程的精度。</p><h1 id="评价和测试">5. 评价和测试</h1><p><img src="/2020/06/02/Review-3D-Lidar-Localization/2020-06-02-15-11-52.png"></p><p><img src="/2020/06/02/Review-3D-Lidar-Localization/2020-06-02-15-12-08.png"></p><p>请注意，我们只考虑不涉及任何 loop closure的结果。虽然<code>Loam</code>仍然占据着排行榜的前面，但可以明显看出，涉及深度学习的方法正变得越来越精确。基于深度学习的方法被证明会产生非常有前途的结果，并且似乎代表了正确的路径，以便在未来解决这个挑战，基于三维特征检测与匹配的方法在实际应用中已被证明是最先进的方法。</p><p>DeepICP报告的平均结果优于其他的训练方法，然而，由于两个主要原因，我们很难把它们称为最先进的方法：</p><ul><li>(DeepICP)大约需要2秒钟来配准每一帧</li><li>这些方法在测试数据集上的结果尚未见报道，在测试数据集上的良好结果将证明，这些方法不仅适用于深度神经网络已经看到的数据，而且能够用于真实数据</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;d-激光雷达定位方法汇总&quot;&gt;1. 3D-激光雷达定位方法汇总&lt;/h1&gt;
&lt;p&gt;本次调查的目的是回顾和介绍与三维激光雷达定位相关的工作，比较文献中报道的不同结果，并讨论各自的优缺点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/02/Review-3D-Li
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>KAIST-Urban-数据集-论文阅读</title>
    <link href="http://yoursite.com/2020/05/26/KAIST-Urban-%E6%95%B0%E6%8D%AE%E9%9B%86-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2020/05/26/KAIST-Urban-%E6%95%B0%E6%8D%AE%E9%9B%86-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2020-05-26T02:49:38.000Z</published>
    <updated>2020-05-26T08:45:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="complex-urban-dataset-with-multi-level-sensors-from-highly-diverse-urban-environments">Complex urban dataset with multi-level sensors from highly diverse urban environments</h1><p><img src="/2020/05/26/KAIST-Urban-%E6%95%B0%E6%8D%AE%E9%9B%86-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-05-26-10-50-26.png"></p><h1 id="摘要">摘要</h1><p>提供了数据集地址: http://irap.kaist.ac.kr/dataset.</p><ul><li>提供多环境多场景的数据，如市区，公寓，或者是地下停车场</li><li>提供了以高精度导航传感器和半自动回环处理的SLAM算法的定位基准</li><li>提供两个级别准确度的传感器数据（商用和消费级别）</li><li>提供3D点云（LAS格式）以及相应的viewer</li><li>提供ROS下的开发者工具</li></ul><h1 id="介绍">介绍</h1><p>下表展示了最近的一些自动驾驶或3D mapping的数据集</p><p><img src="/2020/05/26/KAIST-Urban-%E6%95%B0%E6%8D%AE%E9%9B%86-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20200526142830092.png"></p><h1 id="系统概述">系统概述</h1><p><img src="/2020/05/26/KAIST-Urban-%E6%95%B0%E6%8D%AE%E9%9B%86-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20200526143521807.png"></p><p><img src="/2020/05/26/KAIST-Urban-%E6%95%B0%E6%8D%AE%E9%9B%86-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20200526143800560.png"></p><p><img src="/2020/05/26/KAIST-Urban-%E6%95%B0%E6%8D%AE%E9%9B%86-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20200526144005553.png"></p><h1 id="传感器坐标系">传感器坐标系</h1><p><img src="/2020/05/26/KAIST-Urban-%E6%95%B0%E6%8D%AE%E9%9B%86-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20200526151205978.png"></p><p><img src="/2020/05/26/KAIST-Urban-%E6%95%B0%E6%8D%AE%E9%9B%86-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20200526151436568.png"></p><p><img src="/2020/05/26/KAIST-Urban-%E6%95%B0%E6%8D%AE%E9%9B%86-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20200526151510086.png"></p><p><img src="/2020/05/26/KAIST-Urban-%E6%95%B0%E6%8D%AE%E9%9B%86-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20200526151559113.png"></p><h1 id="激光雷达与车体坐标系外参标定">激光雷达与车体坐标系外参标定</h1><ol type="1"><li>先根据不同激光雷达的外参关系，将不同激光雷达的点云拼接起来</li><li>因为标定过程是在一个平面（地面）上进行的，因此，当车体中心在地面上时，点云在地面上的高度应该为0。因此，通过调整拼接后的点云的高度为0，可以计算出两个3D激光雷达在车体参考坐标系下的roll，pitch和z值<ol type="1"><li>首先，使用RANSAC算法通过拟合平面来提取地面上的点</li><li>然后，使用SVD分解求出激光雷达相对于车体坐标系的roll，pitch和z值</li><li>对于x，y和yaw值，在空地上控制车辆往返运动，然后从两个相反的视点比较场景，在这个过程中，用到了VRS-GPS和光纤陀螺等高精度的设备。这个过程中，车辆的精确位置主要有VRS-GPS提供，通过对3D点云进行对齐来得到待估计的x，y和yaw值</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;complex-urban-dataset-with-multi-level-sensors-from-highly-diverse-urban-environments&quot;&gt;Complex urban dataset with multi-level sensor
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>驱动-组合导航-星网宇达M2</title>
    <link href="http://yoursite.com/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/"/>
    <id>http://yoursite.com/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/</id>
    <published>2020-05-18T05:39:10.000Z</published>
    <updated>2020-05-20T08:21:16.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ros驱动-组合导航-星网宇达m2">1. ROS驱动-组合导航-星网宇达M2</h1><p>这里使用的是Apollo D-Kit套件，采用的是星网宇达公司的M2组合导航。第一步先对组合导航进行设置，第二步是修改ROS社区开源Package <code>nmea_navsat_driver</code>驱动</p><h1 id="配置m2">2. 配置M2</h1><h2 id="清空输出">2.1. 清空输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cmd,through,usb0,null*ff</span><br><span class="line">$cmd,output,usb0,null*ff</span><br></pre></td></tr></table></figure><h2 id="航向设置">2.2. 航向设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cmd,set,headoffset,0*ff</span><br></pre></td></tr></table></figure><h2 id="检查导航模式">2.3. 检查导航模式</h2><h3 id="设置">2.3.1. 设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$cmd,set,navmode,FineAlign,off*ff</span><br><span class="line">$cmd,set,navmode,coarsealign,off*ff</span><br><span class="line">$cmd,set,navmode,dynamicalign,on*ff</span><br><span class="line">$cmd,set,navmode,gnss,double*ff</span><br><span class="line">$cmd,set,navmode,carmode,on*ff</span><br><span class="line">$cmd,set,navmode,zupt,on*ff</span><br><span class="line">$cmd,set,navmode,firmwareindex,0*ff</span><br></pre></td></tr></table></figure><blockquote><p>如果不行则试试这个: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;$cmd,set,navmode,finealign,off*ff (精对准开&#x2F;关 需要设置成 off)</span><br><span class="line">&gt;$cmd,set,navmode,corsealign,off*ff (粗对准开&#x2F;关 设置成 off)</span><br><span class="line">&gt;$cmd,set,navmode,dynamicalign,on*ff (动态对准开&#x2F;关 设置成 on)</span><br><span class="line">&gt;$cmd,set,navmode,gnss,double *ff (设置成双天线 double)</span><br><span class="line">&gt;$cmd,set,navmode,carmode,on*ff (车载模式开&#x2F;关 设置成 on)</span><br><span class="line">&gt;$cmd,set,navmode,zupt,on*ff (静止模式开&#x2F;关 设置成 on)</span><br><span class="line">&gt;$cmd,set,navmode,firmwareindex,0*ff (固件 0&#x2F;1 除 7660-F01 外都设置成 0</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="检查">2.3.2. 检查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cmd,get,navmode*ff</span><br></pre></td></tr></table></figure><p><img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-18-15-30-25.png"></p><p><img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-18-15-30-45.png"></p><h2 id="设置杆臂值">2.4. 设置杆臂值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置命令为： $cmd,set,leverarm,gnss,x,y,z*ff。（xyz 单位为米）</span><br></pre></td></tr></table></figure><p>（如果 PRI 天线安装在 M2 主机的右、前、上， xyz 则为正，反之 xyz 前面需加负号-）</p><h2 id="设置输出">2.5. 设置输出</h2><p>指令格式:</p><p><code>$cmd,output,comX,cmdname,rate*ff</code></p><h3 id="输出imu原始数据gtimu">2.5.1. 输出IMU原始数据<code>GTIMU</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cmd,output,usb0,gtimu,0.01*ff</span><br></pre></td></tr></table></figure><p><img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-18-15-33-44.png"></p><p><img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-18-15-34-23.png"></p><h3 id="输出rtk定位信息gpgga语句">2.5.2. 输出RTK定位信息<code>GPGGA</code>语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cmd,output,usb0,gpgga,0.2*ff</span><br></pre></td></tr></table></figure><p><img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-18-15-36-41.png"></p><p><img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-18-15-36-57.png"> <img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-18-15-37-15.png"></p><h3 id="输出融合之后的定位信息gpfpd语句">2.5.3. 输出融合之后的定位信息<code>GPFPD</code>语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cmd,output,usb0,gpfpd,0.02*ff</span><br></pre></td></tr></table></figure><p><img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-18-15-38-58.png"></p><p><img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-18-15-39-25.png"> <img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-18-15-39-37.png"> <img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-20-14-37-47.png"></p><p><font color="red" size="5">GPFPD状态输出为4B的时候，表明RTK正常</font></p><h3 id="输出融合之后的标准差协方差">2.5.4. 输出融合之后的标准差（协方差）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cmd,output,usb0,nvstd,2*ff</span><br></pre></td></tr></table></figure><p><img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-18-15-54-18.png"></p><p><img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-18-15-54-32.png"> <img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-18-15-54-44.png"></p><h2 id="设置rtk">2.6. 设置RTK</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$cmd,set,localip,192,168,0,123*ff</span><br><span class="line">$cmd,set,localmask,255,255,255,0*ff</span><br><span class="line">$cmd,set,localgate,192,168,0,1*ff</span><br><span class="line">$cmd,set,netipport,203,107,45,154,8002*ff</span><br><span class="line">$cmd,set,netuser,username:password*ff</span><br><span class="line">$cmd,set,mountpoint,RTCM32_GGB*ff</span><br><span class="line">$cmd,set,ntrip,enable,enable*ff</span><br></pre></td></tr></table></figure><h3 id="检查-1">2.6.1. 检查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cmd,get,netpara*ff</span><br></pre></td></tr></table></figure><p><img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-20-14-29-32.png"></p><h2 id="设置ppp授时输出">2.7. 设置PPP授时输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ppscontrol enable positive 1.0 10000</span><br><span class="line">log com3 gprmc ontime 1 0.25</span><br></pre></td></tr></table></figure><h2 id="保存设置">2.8. 保存设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cmd,save,config*ff</span><br></pre></td></tr></table></figure><h1 id="ros驱动代码">ROS驱动代码</h1><p>已上传至GitHub</p><p>https://github.com/qpc001/M2_navsat_driver</p><p><img src="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/2020-05-20-16-21-09.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ros驱动-组合导航-星网宇达m2&quot;&gt;1. ROS驱动-组合导航-星网宇达M2&lt;/h1&gt;
&lt;p&gt;这里使用的是Apollo D-Kit套件，采用的是星网宇达公司的M2组合导航。第一步先对组合导航进行设置，第二步是修改ROS社区开源Package &lt;code&gt;nmea
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>BASALT-2-3D点的参数化表达</title>
    <link href="http://yoursite.com/2020/05/13/BASALT-2-3D%E7%82%B9%E7%9A%84%E5%8F%82%E6%95%B0%E5%8C%96%E8%A1%A8%E8%BE%BE/"/>
    <id>http://yoursite.com/2020/05/13/BASALT-2-3D%E7%82%B9%E7%9A%84%E5%8F%82%E6%95%B0%E5%8C%96%E8%A1%A8%E8%BE%BE/</id>
    <published>2020-05-13T06:40:35.000Z</published>
    <updated>2020-05-13T07:44:13.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="basalt-2-3d点的参数化表达">BASALT-2-3D点的参数化表达</h1><p><img src="/2020/05/13/BASALT-2-3D%E7%82%B9%E7%9A%84%E5%8F%82%E6%95%B0%E5%8C%96%E8%A1%A8%E8%BE%BE/2020-05-13-14-45-11.png"></p><p><img src="/2020/05/13/BASALT-2-3D%E7%82%B9%E7%9A%84%E5%8F%82%E6%95%B0%E5%8C%96%E8%A1%A8%E8%BE%BE/2020-05-13-14-50-15.png"></p><p><img src="/2020/05/13/BASALT-2-3D%E7%82%B9%E7%9A%84%E5%8F%82%E6%95%B0%E5%8C%96%E8%A1%A8%E8%BE%BE/2020-05-13-14-56-15.png"></p><p><img src="/2020/05/13/BASALT-2-3D%E7%82%B9%E7%9A%84%E5%8F%82%E6%95%B0%E5%8C%96%E8%A1%A8%E8%BE%BE/2020-05-13-15-44-13.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;basalt-2-3d点的参数化表达&quot;&gt;BASALT-2-3D点的参数化表达&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/05/13/BASALT-2-3D%E7%82%B9%E7%9A%84%E5%8F%82%E6%95%B0%E5%8C%96%E8%A1%
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>VINS-Mono-3-初始化和闭环</title>
    <link href="http://yoursite.com/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/"/>
    <id>http://yoursite.com/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/</id>
    <published>2020-04-30T01:10:56.000Z</published>
    <updated>2020-05-04T13:16:16.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vins-mono-3-初始化和闭环">VINS-Mono-3-初始化和闭环</h1><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-12-03.png"></p><h1 id="初始化">初始化</h1><p>初始化要解决什么问题？</p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-30-43.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-12-24.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-14-37.png"></p><h2 id="总流程">总流程</h2><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-15-11.png"></p><h2 id="视觉sfm">视觉sfm</h2><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-16-47.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-17-51.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-18-23.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-20-08.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-20-20.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-21-12.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-23-22.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-26-19.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-27-56.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-28-27.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-29-45.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-30-52.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-36-22.png"></p><h2 id="视觉-imu对齐">视觉-IMU对齐</h2><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-37-29.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-23-17.png"></p><h3 id="已知条件">已知条件</h3><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-23-52.png"></p><h3 id="估计旋转外參q_bc">估计旋转外參<span class="math inline">\(q_{bc}\)</span></h3><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-24-59.png"> <img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-25-28.png"></p><h3 id="估计陀螺仪bias">估计陀螺仪bias</h3><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-26-42.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-39-58.png"></p><h3 id="初始化速度重力向量和尺度因子">初始化速度、重力向量和尺度因子</h3><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-27-02.png"> <img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-27-16.png"> <img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-27-28.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-05-04-21-05-15.png"> <img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-05-04-21-05-38.png"> <img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-05-04-21-06-01.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-42-22.png"></p><h3 id="重力向量调优">重力向量调优</h3><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-28-23.png"> <img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-28-36.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-05-04-21-09-07.png"> <img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-05-04-21-09-57.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-43-11.png"></p><h3 id="坐标系对齐">坐标系对齐</h3><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-29-06.png"></p><h2 id="开放性问题">开放性问题</h2><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-29-36.png"></p><h1 id="闭环检测">闭环检测</h1><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-44-36.png"></p><ul><li><ol type="1"><li>闭环检测</li></ol><ul><li>取原始图像: 为了重新提取特征点，计算描述子</li><li>取特征点</li></ul></li><li><ol start="2" type="1"><li>特征恢复</li></ol><ul><li>建立数据关联: 闭环帧与新帧的特征点关联</li></ul></li><li><ol start="3" type="1"><li>计算约束</li></ol></li><li><ol start="4" type="1"><li>将约束加入Pose Graph</li></ol></li></ul><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-49-36.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-50-28.png"></p><h2 id="闭环节点">闭环节点</h2><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-48-22.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-09-58-56.png"></p><p><code>Process()</code></p><ul><li>取后端关键帧，创建<code>KeyFrame</code>对象<ul><li>提取已有的特征点描述子</li><li>提取新的Fast特征点和描述子</li><li>丢掉原始图像</li></ul></li><li>进行闭环检测</li></ul><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-03-58.png"></p><p>暴力匹配:</p><ul><li>使用当前帧所有特征点与闭环帧的所有特征点进行暴力匹配，同时匹配会产生大量外点</li></ul><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-06-49.png"></p><p><img src="/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/2020-04-30-10-08-32.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vins-mono-3-初始化和闭环&quot;&gt;VINS-Mono-3-初始化和闭环&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/04/30/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第五章-线性系统的能控性和能观性</title>
    <link href="http://yoursite.com/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/"/>
    <id>http://yoursite.com/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/</id>
    <published>2020-04-29T13:19:53.000Z</published>
    <updated>2020-04-29T15:15:23.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性系统的能控性和能观性">1. 线性系统的能控性和能观性</h1><p>能控性和能观测性是现代控制理论中两个很重要的基础性概念，<code>最优控制</code>和<code>最佳估计</code>都是以它们的存在为条件的，是由 Kalmen（卡尔曼）1960年首先提出的。</p><p>可控性和可观测性就是回答<code>“系统的状态是否能控制“</code>和<code>”状态的变化能否由输出测量出来</code>这两个问题。</p><h2 id="例子">1.1. 例子</h2><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-22-56.png"></p><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-23-32.png"></p><ul><li><span class="math inline">\(x2=u_c\)</span>不能控</li><li><span class="math inline">\(x_1=i_L\)</span>不能观</li></ul><h1 id="定义">2. 定义</h1><h2 id="状态能控性">2.1. 状态能控性</h2><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-24-47.png"></p><h2 id="状态能观性">2.2. 状态能观性</h2><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-25-06.png"></p><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-25-21.png"></p><h1 id="线性连续时间系统能控性判据">3. 线性连续时间系统能控性判据</h1><h2 id="线性定常系统能控性判据">3.1. 线性定常系统能控性判据</h2><p>假设有线性定常系统</p><p><span class="math display">\[\left \{    \begin{aligned}        &amp;\dot{x}=Ax+Bu \\        &amp;x(0)=x_0    \end{aligned}\right.\]</span></p><h3 id="格拉姆矩阵判据gram">3.1.1. 格拉姆矩阵判据(Gram)</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-28-04.png"></p><p><strong>充要条件</strong></p><ul><li>格拉姆矩阵非奇异</li></ul><h3 id="秩判据">3.1.2. 秩判据</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-29-46.png"></p><h4 id="例子1">3.1.2.1. 例子1</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-30-52.png"></p><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-31-11.png"></p><h4 id="例子2">3.1.2.2. 例子2</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-31-31.png"></p><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-31-40.png"></p><h3 id="pbh秩判据popov-belevitch-hautus">3.1.3. PBH秩判据(Popov-Belevitch-Hautus)</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-32-32.png"></p><h4 id="例子-1">3.1.3.1. 例子</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-32-53.png"></p><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-33-06.png"></p><h3 id="约当规范形判据">3.1.4. 约当规范形判据</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-33-58.png"></p><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-34-33.png"></p><h4 id="例子1-1">3.1.4.1. 例子1</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-35-55.png"></p><h4 id="例子2-1">3.1.4.2. 例子2</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-36-07.png"></p><h2 id="线性时变系统能观性判据">3.2. 线性时变系统能观性判据</h2><p>设有线性时变系统</p><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-39-30.png"></p><h3 id="格拉姆矩阵判据gram-1">3.2.1. 格拉姆矩阵判据(Gram)</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-40-42.png"></p><h3 id="秩判据-1">3.2.2. 秩判据</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-41-00.png"></p><h4 id="例子-2">3.2.2.1. 例子</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-41-16.png"></p><h1 id="线性连续时间系统的能观性判据">4. 线性连续时间系统的能观性判据</h1><h2 id="线性定常系统">4.1. 线性定常系统</h2><p>设有线性定常系统</p><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-42-19.png"></p><h3 id="格拉姆矩阵判据gram-2">4.1.1. 格拉姆矩阵判据(Gram)</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-42-47.png"></p><h3 id="秩判据-2">4.1.2. 秩判据</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-43-39.png"></p><h3 id="pbh秩判据popov-belevitch-hautus-1">4.1.3. PBH秩判据(Popov-Belevitch-Hautus)</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-44-10.png"></p><h3 id="约当规范形判据-1">4.1.4. 约当规范形判据</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-45-39.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-45-52.png"></p><h4 id="例子1-2">4.1.4.1. 例子1</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-47-17.png"></p><h4 id="例子2-2">4.1.4.2. 例子2</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-47-32.png"></p><h4 id="例子3">4.1.4.3. 例子3</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-47-48.png"></p><h4 id="例子4">4.1.4.4. 例子4</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-48-02.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-48-16.png"></p><h4 id="例子5">4.1.4.5. 例子5</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-49-48.png"></p><h2 id="线性时变系统能观性判据-1">4.2. 线性时变系统能观性判据</h2><p>假设有线性时变系统</p><p><span class="math display">\[\left \{    \begin{aligned}        &amp;\dot{x}=A(t)x , x(t_0)=x_0, t,t_0 \in J \\        &amp;y=C(t)x    \end{aligned}\right.\]</span></p><h3 id="格拉姆矩阵判据gram-3">4.2.1. 格拉姆矩阵判据(Gram)</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-55-07.png"></p><h3 id="秩判据-3">4.2.2. 秩判据</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-55-25.png"></p><h1 id="线性离散系统的能控性和能观性判据">5. 线性离散系统的能控性和能观性判据</h1><h2 id="离散系统能控性">5.1. 离散系统能控性</h2><h3 id="线性时变离散系统格拉姆矩阵判据">5.1.1. 线性时变离散系统——格拉姆矩阵判据</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-57-49.png"></p><h3 id="线性定常离散系统秩判据">5.1.2. 线性定常离散系统——秩判据</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-58-24.png"></p><h2 id="离散系统能观性">5.2. 离散系统能观性</h2><p>假设有线性离散系统</p><p><span class="math display">\[\left \{    \begin{aligned}        &amp;x(k+1)=G(k)x(k) \\        &amp;y(k)=C(k)x(k)    \end{aligned}\right.\]</span></p><h3 id="线性时变离散系统格拉姆矩阵判据-1">5.2.1. 线性时变离散系统——格拉姆矩阵判据</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-03-13.png"></p><h3 id="线性定常离散系统秩判据-1">5.2.2. 线性定常离散系统——秩判据</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-10-06.png"></p><h2 id="统离散化后保持能控和能观的条件">5.3. 统离散化后保持能控和能观的条件</h2><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-10-54.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-11-14.png"></p><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-11-52.png"></p><h3 id="例子1-3">5.3.1. 例子1</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-12-06.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-12-22.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-12-32.png"></p><h3 id="例子2-3">5.3.2. 例子2</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-12-53.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-13-20.png"></p><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-14-21.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-14-34.png"></p><h1 id="线性系统能控性与能观测性的对偶关系">6. 线性系统能控性与能观测性的对偶关系</h1><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-16-02.png"></p><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-16-30.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-17-08.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-17-36.png"></p><h1 id="能控标准形和能观测标准形">7. 能控标准形和能观测标准形</h1><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-18-27.png"></p><h2 id="能控规范型">7.1. 能控规范型</h2><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-20-21.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-20-40.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-21-30.png"></p><h3 id="例子-3">7.1.1. 例子</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-29-06.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-29-17.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-29-39.png"></p><h2 id="能观规范型">7.2. 能观规范型</h2><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-30-20.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-30-43.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-30-57.png"></p><h3 id="例子-4">7.2.1. 例子</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-29-06.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-35-30.png"></p><h1 id="系统的能控性能观测性和传递函数阵的关系">8. 系统的能控性、能观测性和传递函数阵的关系</h1><h2 id="系统的结构分解">8.1. 系统的结构分解</h2><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-36-32.png"></p><h3 id="按能控性分解">8.1.1. 按能控性分解</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-38-49.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-39-10.png"></p><h4 id="非奇异变换矩阵t的选取">8.1.1.1. 非奇异变换矩阵T的选取</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-39-43.png"></p><h4 id="例子-5">8.1.1.2. 例子</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-40-40.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-40-55.png"></p><h3 id="按能观性分解">8.1.2. 按能观性分解</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-42-25.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-43-03.png"></p><h4 id="非奇异变换矩阵t的选取-1">8.1.2.1. 非奇异变换矩阵T的选取</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-43-40.png"></p><h4 id="例子-6">8.1.2.2. 例子</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-44-21.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-44-34.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-44-55.png"></p><h3 id="规范分解定理">8.1.3. 规范分解定理</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-08-12.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-08-34.png"></p><p><strong>结论</strong></p><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-09-00.png"></p><h4 id="传递函数矩阵的最小多项式表示形式">8.1.3.1. 传递函数矩阵的最小多项式表示形式</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-11-35.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-12-02.png"></p><p><strong>例子</strong></p><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-12-24.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-12-35.png"></p><h3 id="传递函数中零极点相消定理">8.1.4. 传递函数中零、极点相消定理</h3><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-13-51.png"></p><h4 id="例子-7">8.1.4.1. 例子</h4><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-14-16.png"> <img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-14-30.png"></p><p><img src="/2020/04/29/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-15-13.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性系统的能控性和能观性&quot;&gt;1. 线性系统的能控性和能观性&lt;/h1&gt;
&lt;p&gt;能控性和能观测性是现代控制理论中两个很重要的基础性概念，&lt;code&gt;最优控制&lt;/code&gt;和&lt;code&gt;最佳估计&lt;/code&gt;都是以它们的存在为条件的，是由 Kalmen（卡尔曼）1960
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第五章-线性系统的能控性和能观性</title>
    <link href="http://yoursite.com/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/"/>
    <id>http://yoursite.com/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/</id>
    <published>2020-04-29T13:19:53.000Z</published>
    <updated>2020-04-29T15:15:23.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性系统的能控性和能观性">1. 线性系统的能控性和能观性</h1><p>能控性和能观测性是现代控制理论中两个很重要的基础性概念，<code>最优控制</code>和<code>最佳估计</code>都是以它们的存在为条件的，是由 Kalmen（卡尔曼）1960年首先提出的。</p><p>可控性和可观测性就是回答<code>“系统的状态是否能控制“</code>和<code>”状态的变化能否由输出测量出来</code>这两个问题。</p><h2 id="例子">1.1. 例子</h2><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-22-56.png"></p><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-23-32.png"></p><ul><li><span class="math inline">\(x2=u_c\)</span>不能控</li><li><span class="math inline">\(x_1=i_L\)</span>不能观</li></ul><h1 id="定义">2. 定义</h1><h2 id="状态能控性">2.1. 状态能控性</h2><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-24-47.png"></p><h2 id="状态能观性">2.2. 状态能观性</h2><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-25-06.png"></p><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-25-21.png"></p><h1 id="线性连续时间系统能控性判据">3. 线性连续时间系统能控性判据</h1><h2 id="线性定常系统能控性判据">3.1. 线性定常系统能控性判据</h2><p>假设有线性定常系统</p><p><span class="math display">\[\left \{    \begin{aligned}        &amp;\dot{x}=Ax+Bu \\        &amp;x(0)=x_0    \end{aligned}\right.\]</span></p><h3 id="格拉姆矩阵判据gram">3.1.1. 格拉姆矩阵判据(Gram)</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-28-04.png"></p><p><strong>充要条件</strong></p><ul><li>格拉姆矩阵非奇异</li></ul><h3 id="秩判据">3.1.2. 秩判据</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-29-46.png"></p><h4 id="例子1">3.1.2.1. 例子1</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-30-52.png"></p><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-31-11.png"></p><h4 id="例子2">3.1.2.2. 例子2</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-31-31.png"></p><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-31-40.png"></p><h3 id="pbh秩判据popov-belevitch-hautus">3.1.3. PBH秩判据(Popov-Belevitch-Hautus)</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-32-32.png"></p><h4 id="例子-1">3.1.3.1. 例子</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-32-53.png"></p><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-33-06.png"></p><h3 id="约当规范形判据">3.1.4. 约当规范形判据</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-33-58.png"></p><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-34-33.png"></p><h4 id="例子1-1">3.1.4.1. 例子1</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-35-55.png"></p><h4 id="例子2-1">3.1.4.2. 例子2</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-36-07.png"></p><h2 id="线性时变系统能观性判据">3.2. 线性时变系统能观性判据</h2><p>设有线性时变系统</p><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-39-30.png"></p><h3 id="格拉姆矩阵判据gram-1">3.2.1. 格拉姆矩阵判据(Gram)</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-40-42.png"></p><h3 id="秩判据-1">3.2.2. 秩判据</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-41-00.png"></p><h4 id="例子-2">3.2.2.1. 例子</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-41-16.png"></p><h1 id="线性连续时间系统的能观性判据">4. 线性连续时间系统的能观性判据</h1><h2 id="线性定常系统">4.1. 线性定常系统</h2><p>设有线性定常系统</p><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-42-19.png"></p><h3 id="格拉姆矩阵判据gram-2">4.1.1. 格拉姆矩阵判据(Gram)</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-42-47.png"></p><h3 id="秩判据-2">4.1.2. 秩判据</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-43-39.png"></p><h3 id="pbh秩判据popov-belevitch-hautus-1">4.1.3. PBH秩判据(Popov-Belevitch-Hautus)</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-44-10.png"></p><h3 id="约当规范形判据-1">4.1.4. 约当规范形判据</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-45-39.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-45-52.png"></p><h4 id="例子1-2">4.1.4.1. 例子1</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-47-17.png"></p><h4 id="例子2-2">4.1.4.2. 例子2</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-47-32.png"></p><h4 id="例子3">4.1.4.3. 例子3</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-47-48.png"></p><h4 id="例子4">4.1.4.4. 例子4</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-48-02.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-48-16.png"></p><h4 id="例子5">4.1.4.5. 例子5</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-49-48.png"></p><h2 id="线性时变系统能观性判据-1">4.2. 线性时变系统能观性判据</h2><p>假设有线性时变系统</p><p><span class="math display">\[\left \{    \begin{aligned}        &amp;\dot{x}=A(t)x , x(t_0)=x_0, t,t_0 \in J \\        &amp;y=C(t)x    \end{aligned}\right.\]</span></p><h3 id="格拉姆矩阵判据gram-3">4.2.1. 格拉姆矩阵判据(Gram)</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-55-07.png"></p><h3 id="秩判据-3">4.2.2. 秩判据</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-55-25.png"></p><h1 id="线性离散系统的能控性和能观性判据">5. 线性离散系统的能控性和能观性判据</h1><h2 id="离散系统能控性">5.1. 离散系统能控性</h2><h3 id="线性时变离散系统格拉姆矩阵判据">5.1.1. 线性时变离散系统——格拉姆矩阵判据</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-57-49.png"></p><h3 id="线性定常离散系统秩判据">5.1.2. 线性定常离散系统——秩判据</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-21-58-24.png"></p><h2 id="离散系统能观性">5.2. 离散系统能观性</h2><p>假设有线性离散系统</p><p><span class="math display">\[\left \{    \begin{aligned}        &amp;x(k+1)=G(k)x(k) \\        &amp;y(k)=C(k)x(k)    \end{aligned}\right.\]</span></p><h3 id="线性时变离散系统格拉姆矩阵判据-1">5.2.1. 线性时变离散系统——格拉姆矩阵判据</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-03-13.png"></p><h3 id="线性定常离散系统秩判据-1">5.2.2. 线性定常离散系统——秩判据</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-10-06.png"></p><h2 id="统离散化后保持能控和能观的条件">5.3. 统离散化后保持能控和能观的条件</h2><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-10-54.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-11-14.png"></p><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-11-52.png"></p><h3 id="例子1-3">5.3.1. 例子1</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-12-06.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-12-22.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-12-32.png"></p><h3 id="例子2-3">5.3.2. 例子2</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-12-53.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-13-20.png"></p><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-14-21.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-14-34.png"></p><h1 id="线性系统能控性与能观测性的对偶关系">6. 线性系统能控性与能观测性的对偶关系</h1><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-16-02.png"></p><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-16-30.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-17-08.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-17-36.png"></p><h1 id="能控标准形和能观测标准形">7. 能控标准形和能观测标准形</h1><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-18-27.png"></p><h2 id="能控规范型">7.1. 能控规范型</h2><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-20-21.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-20-40.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-21-30.png"></p><h3 id="例子-3">7.1.1. 例子</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-29-06.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-29-17.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-29-39.png"></p><h2 id="能观规范型">7.2. 能观规范型</h2><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-30-20.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-30-43.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-30-57.png"></p><h3 id="例子-4">7.2.1. 例子</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-29-06.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-35-30.png"></p><h1 id="系统的能控性能观测性和传递函数阵的关系">8. 系统的能控性、能观测性和传递函数阵的关系</h1><h2 id="系统的结构分解">8.1. 系统的结构分解</h2><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-36-32.png"></p><h3 id="按能控性分解">8.1.1. 按能控性分解</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-38-49.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-39-10.png"></p><h4 id="非奇异变换矩阵t的选取">8.1.1.1. 非奇异变换矩阵T的选取</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-39-43.png"></p><h4 id="例子-5">8.1.1.2. 例子</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-40-40.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-40-55.png"></p><h3 id="按能观性分解">8.1.2. 按能观性分解</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-42-25.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-43-03.png"></p><h4 id="非奇异变换矩阵t的选取-1">8.1.2.1. 非奇异变换矩阵T的选取</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-43-40.png"></p><h4 id="例子-6">8.1.2.2. 例子</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-44-21.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-44-34.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-22-44-55.png"></p><h3 id="规范分解定理">8.1.3. 规范分解定理</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-08-12.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-08-34.png"></p><p><strong>结论</strong></p><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-09-00.png"></p><h4 id="传递函数矩阵的最小多项式表示形式">8.1.3.1. 传递函数矩阵的最小多项式表示形式</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-11-35.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-12-02.png"></p><p><strong>例子</strong></p><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-12-24.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-12-35.png"></p><h3 id="传递函数中零极点相消定理">8.1.4. 传递函数中零、极点相消定理</h3><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-13-51.png"></p><h4 id="例子-7">8.1.4.1. 例子</h4><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-14-16.png"> <img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-14-30.png"></p><p><img src="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/2020-04-29-23-15-13.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性系统的能控性和能观性&quot;&gt;1. 线性系统的能控性和能观性&lt;/h1&gt;
&lt;p&gt;能控性和能观测性是现代控制理论中两个很重要的基础性概念，&lt;code&gt;最优控制&lt;/code&gt;和&lt;code&gt;最佳估计&lt;/code&gt;都是以它们的存在为条件的，是由 Kalmen（卡尔曼）1960
      
    
    </summary>
    
    
      <category term="控制相关" scheme="http://yoursite.com/categories/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/"/>
    
      <category term="线性系统理论" scheme="http://yoursite.com/categories/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>倒立摆分析</title>
    <link href="http://yoursite.com/2020/04/22/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E5%80%92%E7%AB%8B%E6%91%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/04/22/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E5%80%92%E7%AB%8B%E6%91%86%E5%88%86%E6%9E%90/</id>
    <published>2020-04-22T06:23:15.000Z</published>
    <updated>2020-05-18T06:42:36.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="倒立摆案例">1. 倒立摆案例</h1><p><img src="/2020/04/22/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E5%80%92%E7%AB%8B%E6%91%86%E5%88%86%E6%9E%90/2020-04-22-14-23-55.png"></p><p><img src="/2020/04/22/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E5%80%92%E7%AB%8B%E6%91%86%E5%88%86%E6%9E%90/2020-04-22-14-24-21.png"></p><h1 id="法一">2. 法一</h1><h2 id="已知参数">2.1. 已知参数</h2><p>假设:</p><ul><li>摆的重心坐标<span class="math inline">\((z+ l\sin \theta,l \cos \theta)\)</span></li><li><span class="math inline">\(\theta\)</span>从垂直向上，向右为正方向</li><li><span class="math inline">\(u\)</span>向右为正方向</li></ul><h2 id="对摆进行水平受力分析">2.2. 对摆进行水平受力分析</h2><p>摆在水平方向，受到接合处向右的力<span class="math inline">\(H\)</span></p><p>根据牛顿第二定律，<span class="math inline">\(F=ma\)</span>，有</p><p><span class="math display">\[\begin{aligned}    H &amp;=m \frac{d^2(z+l \sin \theta)}{dt^2} \\    &amp;=m\frac{d( \dot{z}+l \cos \theta \dot{ \theta })}{dt} \\    &amp;=m( \ddot{z}+l \cos\theta \ddot{ \theta}-\sin\theta \dot{ \theta}^2) \\    &amp;=m\ddot{z}+ml\cos\theta\ddot{ \theta }-ml\sin\theta\dot{ \theta }^2\end{aligned}   \tag{1}\]</span></p><h2 id="对车进行水平受力分析">2.3. 对车进行水平受力分析</h2><p>根据牛顿第二定律，<span class="math inline">\(F=ma\)</span>，有</p><p><span class="math display">\[\begin{aligned}    u-H=M\ddot{z} \tag{2}\end{aligned}\]</span></p><p>将(1)带入(2)，得到</p><p><span class="math display">\[    \Rightarrow u=(M+m)\ddot{z}++ml\cos\theta\ddot{\theta}-ml\sin\theta\dot{\theta}^2   \tag{3}\]</span></p><h2 id="对摆进行竖直方向受力分析">2.4. 对摆进行竖直方向受力分析</h2><p>根据牛顿第二定律，<span class="math inline">\(F=ma\)</span>，有</p><p><span class="math display">\[\begin{aligned}    v-mg&amp;=m\frac{d^2(l\cos\theta)}{dt^2} \\    &amp;=m\frac{d(l(-\sin \theta \dot{\theta}))}{dt} \\    &amp;=ml(-\cos \theta \dot{\theta}^2 - \sin \theta \ddot{\theta}) \\    &amp;=ml\sin \theta \ddot{\theta} - ml \cos \theta \dot{\theta}^2\end{aligned}   \tag{4}\]</span></p><h2 id="对摆进行转矩平衡分析">2.5. 对摆进行转矩平衡分析</h2><p>在这里，将摆视为绕着杆的重心旋转，那么，杆在端点(也就是接合处)受到的力沿杆方向进行分解，可以得到两个作用相反的力，分别为<span class="math inline">\(H\cos \theta\)</span>和<span class="math inline">\(v \sin \theta\)</span>，不难发现，<span class="math inline">\(H\cos \theta\)</span>使的角<span class="math inline">\(\theta\)</span>减小，而<span class="math inline">\(v \sin \theta\)</span>使<span class="math inline">\(\theta\)</span>增大</p><p><img src="/2020/04/22/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E5%80%92%E7%AB%8B%E6%91%86%E5%88%86%E6%9E%90/2020-04-22-14-46-35.png"></p><p>根据转矩平衡，和外力转矩 = 转动惯量 * 角加速度，即有<span class="math inline">\(M=J\alpha\)</span>，得:</p><p><span class="math display">\[vl\sin \theta - Hl \cos \theta = J \ddot{\theta} \tag{5}\]</span></p><p>又根据(1)和(4)，</p><p><span class="math display">\[\left \{    \begin{aligned}        H=m\ddot{z}+ml\cos\theta\ddot{\theta}-ml\sin\theta\dot{\theta}^2 \\        v=mg+ml\sin \theta \ddot{\theta} - ml \cos \theta \dot{\theta}^2    \end{aligned}\right.\]</span></p><p>代入式(5)，得到</p><p><span class="math display">\[\begin{aligned}    -m\ddot{z}l\cos \theta - ml^2(\cos^2 \theta-\sin^2 \theta)\ddot{\theta}+mgl\theta = J \ddot{\theta} \end{aligned} \tag{6}\]</span></p><h2 id="近似化简">2.6. 近似化简</h2><p><span class="math inline">\(\theta\)</span>很小的时候，近似有</p><p><span class="math display">\[\begin{aligned}    \cos \theta = 1 \\    \sin \theta =\theta \\    (\frac{d \theta}{dt})^2=\dot{\theta}^2 \approx0\end{aligned}\]</span></p><p>因此，将式(3)和式(6)进行化简，有:</p><p><span class="math display">\[\left \{    \begin{aligned}        u=(M+m)\ddot{z}+ml \ddot{\theta} \\        (J+ml^2)\ddot{\theta}=-ml\ddot{z}+mgl\theta    \end{aligned}\right .            \tag{7}\]</span></p><p>求解方程组(7)，最终，可以得到系统的状态空间描述:</p><p><span class="math display">\[\begin{aligned}    \dot{X}=    \begin{bmatrix}        \dot{z} \\ \ddot{z} \\ \dot{\theta} \\ \ddot{\theta}    \end{bmatrix} =     \begin{bmatrix}        0 &amp; 1 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; \frac{-m^2gl^2}{J(M+m)+Mml^2} &amp; 0 \\        0 &amp; 0 &amp; 0 &amp; 1 \\        0 &amp; 0 &amp; \frac{mgl(M+m)}{J(M+m)+Mml^2} &amp; 0     \end{bmatrix}    \begin{bmatrix}        z \\ \dot{z} \\ \theta \\ \dot{\theta}    \end{bmatrix}    +    \begin{bmatrix}        0 \\        \frac{J+ml^2}{J(M+m)+Mml^2} \\        0 \\        \frac{-ml}{J(M+m)+Mml^2}    \end{bmatrix}    u               \end{aligned} \tag{8}\]</span></p><p>进一步地，如果杆是均匀质杆，那么有转动惯量<span class="math inline">\(J=\frac{ml^2}{3}\)</span>，</p><p>代入到式(7)的第二个方程，有</p><p><span class="math display">\[\begin{aligned}    (\frac{ml^2}{3}+ml^2)\ddot{\theta}=-ml\ddot{z}+mgl\theta\end{aligned}   \tag{9}\]</span></p><p>即可求出<span class="math inline">\(\ddot{\theta}\)</span>的表达</p><p><span class="math display">\[\ddot{\theta}=\frac{3g}{4l}\theta-\frac{3}{4l}\ddot{z}\]</span></p><p>如果令输入<span class="math inline">\(u=\ddot{z}\)</span>，那么，状态方程可以写成</p><p><span class="math display">\[\begin{aligned}    \dot{X}=    \begin{bmatrix}        \dot{z} \\ \ddot{z} \\ \dot{\theta} \\ \ddot{\theta}    \end{bmatrix} =     \begin{bmatrix}        0 &amp; 1 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 0 &amp; 1 \\        0 &amp; 0 &amp; \frac{3g}{4l} &amp; 0     \end{bmatrix}    \begin{bmatrix}        z \\ \dot{z} \\ \theta \\ \dot{\theta}    \end{bmatrix}    +    \begin{bmatrix}        0 \\        1 \\        0 \\        \frac{-3}{4l}    \end{bmatrix}    u              \end{aligned}   \tag{8}\]</span></p><h1 id="法二">3. 法二</h1><p>拉格朗日约束法</p><p>因此，假设有某个广义坐标<span class="math inline">\(q\)</span>以及拉格朗日算子<span class="math inline">\(L\)</span>，则拉格朗日方程可表示为:</p><p><span class="math display">\[    \frac{d}{dt}(\frac{d L}{d \dot{q}})-\frac{d L}{d q}=f\]</span></p><p>其中，f为沿着广义坐标轴方向上的外力。</p><p>对于上述系统，定义由<span class="math inline">\(z,\theta\)</span>组成的广义坐标系，T为系统的动能，V为系统的是势能。</p><h2 id="小车动能">3.1. 小车动能</h2><p><span class="math display">\[    T_M=\frac{1}{2}M\dot{z}^2       \tag{9}\]</span></p><h2 id="杆动能">3.2. 杆动能</h2><p><span class="math display">\[\begin{aligned}    T_m&amp;=\frac{1}{2}mv^2+\frac{1}{2}J\dot{\theta}^2 \\    &amp;=\frac{1}{2}m\{\underbrace{[\frac{d(z+l\sin \theta)}{dt}]^2}_{v_x}+\underbrace{[\frac{d(l\cos \theta)}{dt}]^2}_{v_y}\}+\frac{1}{2}J\dot{\theta}^2\end{aligned}               \tag{10}\]</span></p><h2 id="系统总动能">3.3. 系统总动能</h2><p><span class="math display">\[\begin{aligned}    T=T_M+T_m    &amp;=\frac{1}{2}M\dot{z}^2+\frac{1}{2}mv^2+\frac{1}{2}J\dot{\theta}^2 \\    &amp;=\frac{1}{2}M\dot{z}^2+\frac{1}{2}m\{\underbrace{[\frac{d(z+l\sin \theta)}{dt}]^2}_{v_x}+\underbrace{[\frac{d(l\cos \theta)}{dt}]^2}_{v_y}\}+\frac{1}{2}J\dot{\theta}^2 \\    &amp;=\frac{1}{2}M\dot{z}^2+\frac{1}{2}m\dot{z}^2+m\dot{z}\cos \theta \dot{\theta}+\frac{2}{3}ml^2\theta^2\end{aligned}           \tag{11}\]</span></p><h2 id="系统总势能">3.4. 系统总势能</h2><p><span class="math display">\[    V=mgl\cos \theta\]</span></p><h2 id="构造拉格朗日约束">3.5. 构造拉格朗日约束</h2><p>拉格朗日算子</p><p><span class="math display">\[\begin{aligned}    L=T-V= \frac{1}{2}M\dot{z}^2+\frac{1}{2}m\dot{z}^2+m\dot{z}\cos \theta \dot{\theta}+\frac{2}{3}ml^2\theta^2 - mgl\cos \theta\end{aligned}           \tag{12}\]</span></p><p>由于在广义坐标轴<span class="math inline">\(\theta\)</span>上没有外力作用，因此f=0,所以有s拉格朗日方程:</p><p><span class="math display">\[    \frac{d}{dt}(\frac{d L}{d \dot{\theta}})-\frac{d L}{d \theta}=0     \tag{13}\]</span></p><p>需计算如下</p><p><span class="math display">\[\frac{d L}{d \theta}=-m\dot{z}l \sin \theta \dot{\theta}+ mgl \sin \theta       \tag{14}\]</span></p><p><span class="math display">\[    \frac{d L}{d \dot{\theta}}=m\dot{z}l\cos\theta+\frac{4}{3}ml^2\dot{\theta}      \tag{15}\]</span></p><p><span class="math display">\[\frac{d}{dt}(\frac{d L}{d \dot{\theta}}) = m\ddot{z}\cos \theta - m \dot{z}l\sin \theta \dot{\theta}+\frac{4}{3}ml^2\ddot{\theta}           \tag{16}\]</span></p><p>将式(14)(15)(16)代入式(13)，并且使用近似<span class="math inline">\(\cos \theta=1 , \sin \theta=\theta\)</span>，因此有</p><p><span class="math display">\[    m\ddot{z}l+\frac{4}{3}ml^2\ddot{\theta}-mgl\theta=0    \tag{17}\]</span></p><h2 id="系统状态空间表达">3.6. 系统状态空间表达</h2><p>选取系统状态变量<span class="math inline">\(X\)</span></p><p><span class="math display">\[\begin{aligned}    X=    \begin{bmatrix}        z \\ \dot{z} \\ \theta \\ \dot{\theta}    \end{bmatrix}~~~    Y=    \begin{bmatrix}        z \\        \theta    \end{bmatrix}\end{aligned}\]</span></p><p>如果令输入<span class="math inline">\(u=\ddot{z}\)</span>，那么，根据式(17)，状态方程可以写成</p><p><span class="math display">\[\begin{aligned}    \dot{X}=    \begin{bmatrix}        \dot{z} \\ \ddot{z} \\ \dot{\theta} \\ \ddot{\theta}    \end{bmatrix} =     \begin{bmatrix}        0 &amp; 1 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 0 &amp; 1 \\        0 &amp; 0 &amp; \frac{3g}{4l} &amp; 0     \end{bmatrix}    \begin{bmatrix}        z \\ \dot{z} \\ \theta \\ \dot{\theta}    \end{bmatrix}    +    \begin{bmatrix}        0 \\        1 \\        0 \\        \frac{-3}{4l}    \end{bmatrix}    u               \end{aligned} \tag{18}\]</span></p><p><span class="math display">\[\begin{aligned}    Y=    \begin{bmatrix}        1 &amp; 0 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 1 &amp; 0    \end{bmatrix}        \begin{bmatrix}        z \\ \dot{z} \\ \theta \\ \dot{\theta}    \end{bmatrix}    +    \begin{bmatrix}        0 \\        0     \end{bmatrix}    u\end{aligned}       \tag{19}\]</span></p><h2 id="能观性能控性分析">3.7. 能观性能控性分析</h2><p>已知系统状态方程:</p><p><span class="math display">\[\begin{aligned}    \dot{X}=    \begin{bmatrix}        \dot{z} \\ \ddot{z} \\ \dot{\theta} \\ \ddot{\theta}    \end{bmatrix} =     \begin{bmatrix}        0 &amp; 1 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 0 &amp; 1 \\        0 &amp; 0 &amp; \frac{3g}{4l} &amp; 0     \end{bmatrix}    \begin{bmatrix}        z \\ \dot{z} \\ \theta \\ \dot{\theta}    \end{bmatrix}    +    \begin{bmatrix}        0 \\        1 \\        0 \\        \frac{-3}{4l}    \end{bmatrix}    u               \end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}    Y=    \begin{bmatrix}        1 &amp; 0 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 1 &amp; 0    \end{bmatrix}        \begin{bmatrix}        z \\ \dot{z} \\ \theta \\ \dot{\theta}    \end{bmatrix}    +    \begin{bmatrix}        0 \\        0     \end{bmatrix}    u\end{aligned}      \]</span></p><h3 id="构造能观性判别矩阵">3.7.1. 构造能观性判别矩阵</h3><p><span class="math display">\[\begin{aligned}    \begin{bmatrix}        C \\ CA \\ CA^2 \\ CA^3    \end{bmatrix}    =    \begin{bmatrix}        1 &amp; 0 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 1 &amp; 0 \\         - &amp; - &amp; - &amp; - \\        0 &amp; 1 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 0 &amp; 1 \\        - &amp; - &amp; - &amp; - \\        0 &amp; 0 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; \frac{3g}{4l} &amp; 0 \\         - &amp; - &amp; - &amp; - \\        0 &amp; 0 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 0 &amp; \frac{3g}{4l} \\    \end{bmatrix}\end{aligned}\]</span></p><p>可得，(实际上，仅需要算到CA的时候，就可以判断rank=4了)</p><p><span class="math display">\[\begin{aligned}    rank    \begin{bmatrix}        C \\ CA \\ CA^2 \\ CA^3    \end{bmatrix}=4\end{aligned}\]</span></p><p>因此，系统完全能观</p><h3 id="构造能控性判别矩阵">3.7.2. 构造能控性判别矩阵</h3><p><span class="math display">\[\begin{aligned}    \begin{bmatrix}        B &amp; AB &amp; A^2b &amp; A^3B    \end{bmatrix}    =    \begin{bmatrix}        0 &amp; 1-\frac{3}{4l} &amp; 0 &amp; \frac{-9g}{16l^2} \\        1 &amp; 0 &amp; 0 &amp; 0 \\        0 &amp; -\frac{3}{4l} &amp; 0 &amp; \frac{-9g}{16l^2} \\        -\frac{3}{4l} &amp; 0 &amp; \frac{-9g}{16l^2} &amp; 0    \end{bmatrix}\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}    rank    \begin{bmatrix}        B &amp; AB &amp; A^2b &amp; A^3B    \end{bmatrix}=4\end{aligned}\]</span></p><p>因此，系统完全能控</p><h2 id="稳定性分析">3.8. 稳定性分析</h2><p>该一级倒立摆系统的状态空间方程为</p><p><span class="math display">\[\left \{    \begin{aligned}        \dot{x}(t)=Ax(t)+Bu(t) \\        y(t)=Cx(t)+Du(t)    \end{aligned}\right .\]</span></p><p>可知，原系统是非线性系统，在平衡点处进行线性化，得到</p><p><span class="math display">\[\begin{aligned}    \dot{X}=    \begin{bmatrix}        \dot{z} \\ \ddot{z} \\ \dot{\theta} \\ \ddot{\theta}    \end{bmatrix} =     \begin{bmatrix}        0 &amp; 1 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 0 &amp; 1 \\        0 &amp; 0 &amp; \frac{3g}{4l} &amp; 0     \end{bmatrix}    \begin{bmatrix}        z \\ \dot{z} \\ \theta \\ \dot{\theta}    \end{bmatrix}    +    \begin{bmatrix}        0 \\        1 \\        0 \\        \frac{-3}{4l}    \end{bmatrix}    u             \end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}    Y=    \begin{bmatrix}        1 &amp; 0 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 1 &amp; 0    \end{bmatrix}        \begin{bmatrix}        z \\ \dot{z} \\ \theta \\ \dot{\theta}    \end{bmatrix}    +    \begin{bmatrix}        0 \\        0     \end{bmatrix}    u\end{aligned}\]</span></p><p>取以下参数</p><ul><li><span class="math inline">\(g=9.8m/s^2\)</span></li><li><span class="math inline">\(l=0.25m\)</span></li></ul><p>可以得到系统矩阵A如下</p><p><span class="math display">\[\begin{aligned}    A=    \begin{bmatrix}        0 &amp; 1 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 0 &amp; 0 \\        0 &amp; 0 &amp; 0 &amp; 1 \\        0 &amp; 0 &amp; 29.4 &amp; 0     \end{bmatrix}\end{aligned}\]</span></p><p>利用特征方程<span class="math inline">\(det(\lambda I-A)=0\)</span>，可以计算出矩阵A的特征值:</p><p><span class="math display">\[    \lambda_{1,2}=0, \lambda_{3,4}=\pm 5.42\]</span></p><p>因此，可以看到，系统有两个为0的特征根，另外两个特征根一个在复平面左侧，另外一个具有正的实部，根据<code>Lyapunov</code>第一法稳定判据，可以判断，原系统不稳定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;倒立摆案例&quot;&gt;1. 倒立摆案例&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/04/22/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E5%80%92%E7%AB%8B%E6%91%86%E5%88%86%E6%9E%90/202
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Lego-Loam论文阅读</title>
    <link href="http://yoursite.com/2020/04/21/Lego-Loam%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2020/04/21/Lego-Loam%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2020-04-21T01:12:05.000Z</published>
    <updated>2020-04-21T04:19:43.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lego-loam-lightweight-and-ground-optimized-lidar-odometry-and-mapping-on-variable-terrain">LeGO-LOAM: Lightweight and Ground-Optimized Lidar Odometry and Mapping on Variable Terrain</h1><p><img src="/2020/04/21/Lego-Loam%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-21-09-15-15.png"></p><h1 id="摘要">摘要</h1><p>提出了一种轻量级的，地面优化的激光雷达里程计和建图方法——LeGO-LOAM，一种实时的六自由度的地面车辆位姿估计工具。</p><p><code>LeGO-LOAM</code>是轻量级的，可以在低算力的嵌入式设备中达到实时的位姿估计，同时，也是地面优化的，在分割和优化步骤中，利用了地面信息的存在来加以优化。</p><p>首先应用点云分割来滤除噪声，然后特征提取，获得平面特征和边缘特征。一个两步的Levenberg-Marquardt优化方法，然后根据平面和边缘的特征，来求解连续扫描帧之间的六个自由度的变换。</p><p>我们使用<code>LeGO-LOAM</code>与当前先进的<code>LOAM</code>进行对比，使用从variable-terrain收集的地面车辆数据集，然后展示了<code>LeGO-LOAM</code>达到了相似或更好的准确度，并且减少了计算量。</p><p>我们也整合了<code>LeGO-LOAM</code>到SLAM框架中，来消除漂移导致的位姿估计误差。</p><h1 id="介绍">介绍</h1><ul><li>第一步中，从地面获取的平面特征用来获得观测<span class="math inline">\([t_z,\theta_{roll},\theta_{pitch}]\)</span></li><li>第二步中，剩下的<span class="math inline">\([t_x,t_y,\theta_{yaw}]\)</span>通过匹配边缘特征(从分割的点云中获取的)来观测得到</li></ul><p>我们也整合了回环检测功能来修正运动估计的漂移。</p><h1 id="测试系统硬件">测试系统硬件</h1><ul><li><p>VLP-16（测量距离100米，准确度+-3m，垂直视场角+-15度，水平视场角360度），16线雷达提供了垂直的角度分辨率为2度，水平分辨率0.1度到0.4度，基于旋转的速率</p></li><li><p>HDL-64E（KITTI数据集中），垂直视场角26.9度，水平360度，但是有48线</p></li><li><p>I7-4710MQ，2.5Ghz</p></li><li><p>TX2——ARM Cortex-A57 CPU</p></li></ul><h1 id="系统概述">系统概述</h1><h2 id="全系统概况">全系统概况</h2><p>提出的框架如图1所示</p><p><img src="/2020/04/21/Lego-Loam%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-21-09-37-50.png"></p><p>全系统分为5个部分</p><ul><li>(1)分割 取一帧扫描点云，然后投影到range Image用来进行分割(分段)，分割之后的点云被送到特征提取模块</li><li>(2)特征提取 对range Image进行特征提取，提取平面和线特征？</li><li>(3)lidar Odometry 使用提取得到的特征，寻找连续两帧之间的变换</li><li>(4)lidar Mapping 这些特征进一步的交给lidar mapping来处理，对他们进行全局的配准</li><li>(5)整合 最后，融合<code>lidar Odometry</code>和<code>lidar Mapping</code>模块的位姿估计，输出最终的位姿估计</li></ul><p>提出的框架是为了提高地面车辆的位姿估计的效率和准确度</p><h2 id="分割模块">分割模块</h2><p>令<span class="math inline">\(P_t={p_1,p_2,\cdots,p_n}\)</span>为在t时刻获得的点云，其中<span class="math inline">\(p_i\)</span>是点云<span class="math inline">\(P_t\)</span>中的一个点。</p><p><span class="math inline">\(P_t\)</span>首先被投影到range Image上，分辨率是1800×16（360/0.2×16）,因为VLP-16的水平和垂直角分辨率是0.2度和2度。点云中每一个有效点<span class="math inline">\(p_i\)</span>在深度图中使用一个独特的像素点来表示。深度值<span class="math inline">\(r_i\)</span>与点<span class="math inline">\(p_i\)</span>所代表的点<span class="math inline">\(p_i\)</span>到传感器的欧式距离有关。</p><p>由于斜坡地形在许多环境中都很常见，所以我们不假定地面是平的。</p><p>对距离图像进行按列估计，可看作是对地平面的估计，因此在分割之前，进行地面点提取。</p><p>经过这一步处理，可能代表地面的点被标记为<code>ground</code>，然后不参与下一步分割。</p><p>然后，将一种基于图像的分割方法[23]应用到深度图中，将点分组成多个簇，同一簇的点被分配得到一个独特的label。注意，地面点是一个特殊的簇。</p><p>对点云进行分割，有利于提高后面处理效率和特征提取的准确度。假设机器人在噪声较大的环境下运行，小的物体如树叶，可能会形成一些琐碎且不可靠的特征，因为在连续两次扫描中不太可能看到。</p><p>为了对点云进行快速可靠的特征提取，我们忽略小于30个点的簇，分割前后的点云如图2所示</p><p><img src="/2020/04/21/Lego-Loam%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-21-10-11-55.png"></p><p>原始的点云包含许多点，这些点是从周围的植被中获得的，这些植被可能产生不可靠的特征。</p><p>经过处理之后，仅有图2(b)所示的点云可能包含着大的物体，如卡车和地面点，这些用于进一步的处理，同时，深度图也仅仅保留这部分点的信息。</p><p>我们同时有了每个点的3个属性</p><ul><li>标签（地面点标签、分割的标签）</li><li>深度图中的行和列索引</li><li>代表的距离值</li></ul><h2 id="特征提取">特征提取</h2><p>特征提取与文献[20]相似，不同的是，我们从地面点和点云分割之后点进行特征提取，而不是对原始点云数据进行特征提取。</p><p>令<span class="math inline">\(\mathcal{S}\)</span>作为深度图中与点<span class="math inline">\(p_i\)</span>同一行的连续点集合。</p><p>有一半的点是点<span class="math inline">\(p_i\)</span>的另一面（另一个方向）。在本文，设置<span class="math inline">\(|S|\)</span>为10</p><p>我们可以计算出S中点<span class="math inline">\(p_i\)</span>的粗糙度</p><p><img src="/2020/04/21/Lego-Loam%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-21-10-20-59.png"></p><ol type="1"><li>计算每个点<span class="math inline">\(p_i\)</span>的粗糙度，令S作为range image中同一行的连续点<span class="math inline">\(p_i\)</span>的点集</li><li>为了从所有方向均匀地提取特征，将range image水平划分为几个相等的sub-image</li><li>按每个点的粗糙度值 对sub-image的每一行中的点进行排序</li><li>使用阈值<span class="math inline">\(c_{th}\)</span>来区分不同特征的类别，大于阈值的，被认为是边特征，小于阈值的则被认为是平面特征。</li><li>从sub-image的每一行中选取不属于地面，且有前<span class="math inline">\(n_{\mathbb{F}_e}\)</span>个最大c值的边特征</li><li>从sub-image的每一行中选取前<span class="math inline">\(n_{\mathbb{F}_p}\)</span>个最小c的平面特征点（可以标记为地面或分段点）</li><li><span class="math inline">\(\mathbb{F}_e\)</span>和<span class="math inline">\(\mathbb{F}_p\)</span>为所有sub-image的边缘和平面特征集合，如图2(d)</li><li>从子图中的每一行提取具有最大c的<span class="math inline">\(n_{Fe}\)</span>个边缘特征，他们<strong>肯定</strong>不属于地面</li><li>从子图中的每一行提取具有最小c的<span class="math inline">\(n_{Fp}\)</span>个平面特征，他们<strong>肯定</strong>是地面点</li><li>前两步(8,9)产生了<strong>绝对的</strong>边缘集合<span class="math inline">\(F_e\)</span>和平面集合<span class="math inline">\(F_p\)</span>，特征如图2(c)，其中,<span class="math inline">\(F_e \subset \mathbb{F}_e，F_p \subset \mathbb{F}_p\)</span></li></ol><p><img src="/2020/04/21/Lego-Loam%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-21-11-08-03.png"></p><p>将360°范围图像分为6个子图像。每个子图像的分辨率为300x16。令<span class="math inline">\(n_{Fe}=2,n_{Fp}=4,n_{\mathbb{F}_e}=40,n_{\mathbb{F}_p}=80\)</span></p><h2 id="激光里程计">激光里程计</h2><p>激光雷达测程模块估计两个连续扫描之间传感器的运动。通过点-边和点-面扫描匹配，实现了连续两帧扫描之间的变换关系.</p><p>换句话说，需要从前一帧的<span class="math inline">\(\mathbb{F}_e^{t-1},\mathbb{F}_{p}^{t-1}\)</span>找到当前帧的绝对特征<span class="math inline">\(F_e^t,F_p^t\)</span>点的关联</p><p>改进点</p><ol type="1"><li>标签匹配： 因为<span class="math inline">\(F_e^t,F_p^t\)</span>中的每个特征都有标签，我们只从<span class="math inline">\(\mathbb{F}_e^{t-1},\mathbb{F}_{p}^{t-1}\)</span>找具有相同标签的关联。 对于<span class="math inline">\(F_p^t\)</span>中的平面特征，只有<span class="math inline">\(\mathbb{F}_{p}^{t-1}\)</span>中被标记为地面的点才用来寻找关联。 对于<span class="math inline">\(F_e^t\)</span>中的边缘特征，只从<span class="math inline">\(\mathbb{F}_e^{t-1}\)</span>寻找对应的边缘关联。 这种方式提高匹配准确性，缩小了潜在对应特征的数量。</li><li>两步LM优化<ol type="1"><li>将<span class="math inline">\(F_p^t\)</span>中的平面点和<span class="math inline">\(\mathbb{F}_{p}^{t-1}\)</span>中的特征相匹配，估计得到<span class="math inline">\([t_z,\theta_{roll},\theta_{pitch}]\)</span></li><li>将<span class="math inline">\(F_e^t\)</span>中的边缘点与<span class="math inline">\(\mathbb{F}_e^{t-1}\)</span>中的特征点进行匹配，加上前一步估算的<span class="math inline">\([t_z,\theta_{roll},\theta_{pitch}]\)</span>作为附加条件，得到剩下的<span class="math inline">\([t_x,t_y,\theta_{yaw}]\)</span></li><li>虽然<span class="math inline">\([t_x,t_y,\theta_{yaw}]\)</span>也可以放在第一步进行，但是这样准确度不高，得到的结果难以在第二步中使用</li><li>两个连续扫描之间的6自由度通过对<span class="math inline">\([t_z,\theta_{roll},\theta_{pitch}]\)</span>和<span class="math inline">\([t_x,t_y,\theta_{yaw}]\)</span>融合得到</li><li>两步LM优化，可以达到相同的精度，计算时间减少35%</li></ol></li></ol><h2 id="激光建图">激光建图</h2><p>建图模块以较低的频率运行，匹配<span class="math inline">\(\{\mathbb{F}_e^{t},\mathbb{F}_{p}^{t}\}\)</span>中的特征到之前获得的附近的点云地图<span class="math inline">\(\bar{Q}^{t-1}\)</span>上，来优化位姿估计。然后使用LM迭代，再次进行全局优化</p><p>详细的匹配和优化过程，阅读文献[20]</p><p>LEGO-LOAM一个主要的不同是，如何存储最终点云图：采用的是单独地储存特征集合<span class="math inline">\(\{\mathbb{F}_e^{t},\mathbb{F}_{p}^{t}\}\)</span>，而不是储存单个完整的点云地图。</p><p>例如，<span class="math inline">\(M^{t-1}=\{\{\mathbb{F}_e^{1},\mathbb{F}_{p}^{1}\}\cdots,\{\mathbb{F}_e^{t-1},\mathbb{F}_{p}^{t-1}\} \}\)</span>表示以前的所有特征集合的集合，<span class="math inline">\(M^{t-1}\)</span>中的每个特征集合都与该时刻的激光雷达位姿相关联，然后从<span class="math inline">\(M^{t-1}\)</span>获取点云地图<span class="math inline">\(\bar{Q}^{t-1}\)</span>有两种方法</p><p>一，和Zhang Ji论文类似，选择在传感器视野里面的特征点集获得<span class="math inline">\(\bar{Q}^{t-1}\)</span>，为了简化，我们选择当前传感器位置100米范围内的特征集合，被选择的特征集合经过变换然后融合到一个点云地图<span class="math inline">\(\bar{Q}^{t-1}\)</span>中</p><p>二，在LeGO-LOAM中集成了图优化的方法 1) 图的节点: 每个特征集合对应的传感器位姿 特征集合<span class="math inline">\(\{\mathbb{F}_e^{t},\mathbb{F}_{p}^{t}\}\)</span>被看作为这个节点上的传感器测量数据 2) 激光雷达建图模型的位姿估计漂移一般比较低，可以假设在短时间内没有位姿漂移(drift)。通过选择一组最近几帧的特征集合来构成点云地图<span class="math inline">\(\bar{Q}^{t-1}\)</span>，如<span class="math inline">\(\bar{Q}^{t-1}=\{\{\mathbb{F}_e^{t-k},\mathbb{F}_{p}^{t-k}\}\cdots,\{\mathbb{F}_e^{t-1},\mathbb{F}_{p}^{t-1}\} \}\)</span>，其中，k表示选取集合的数量 3) 新的节点(当前帧位姿)和<span class="math inline">\(\bar{Q}^{t-1}\)</span>中被选择的节点之间加上空间约束，（通过前端LM变换得到的坐标变换） 4) 使用回环检测(loop closure)进一步消除雷达建图的漂移，如果用ICP发现当前特征集和先前特征集之间有匹配，则<strong>添加新约束</strong>，然后通过将Pose Graph发送到如[24]（iSAM2）的优化系统来更新位姿估计。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lego-loam-lightweight-and-ground-optimized-lidar-odometry-and-mapping-on-variable-terrain&quot;&gt;LeGO-LOAM: Lightweight and Ground-Optimiz
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>VINS-Mono-2-后端</title>
    <link href="http://yoursite.com/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/"/>
    <id>http://yoursite.com/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/</id>
    <published>2020-04-20T01:25:12.000Z</published>
    <updated>2020-04-20T03:32:16.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vins-mono-后端">VINS-Mono-后端</h1><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-09-27-54.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-09-30-56.png"></p><h2 id="class-estimator">class Estimator</h2><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-09-31-25.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-09-32-28.png"></p><ul><li>对于单目来说，<code>Camera Id</code>始终为0</li></ul><h2 id="特征点管理器">特征点管理器</h2><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-09-37-31.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-09-38-05.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-09-39-28.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-09-41-41.png"></p><h2 id="因子图">因子图</h2><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-09-43-49.png"></p><h3 id="视觉约束">视觉约束</h3><p><strong>因子图与Hessian矩阵的转换</strong></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-09-46-27.png"></p><h3 id="imu约束">IMU约束</h3><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-09-52-05.png"></p><h3 id="一个简化的例子">一个简化的例子</h3><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-09-55-31.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-09-48.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-10-41.png"></p><h2 id="滑窗优化">滑窗优化</h2><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-12-55.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-13-27.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-14-52.png"></p><h3 id="重投影误差约束">重投影误差约束</h3><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-16-31.png"></p><h4 id="对应代码部分">对应代码部分</h4><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-19-01.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-20-03.png"></p><h3 id="imu误差项约束">IMU误差项约束</h3><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-24-44.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-27-42.png"></p><h2 id="边缘化">边缘化</h2><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-28-32.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-28-55.png"></p><p><strong>VINS-Mono的边缘化策略</strong></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-33-34.png"></p><h3 id="边缘化策略代码部分">边缘化策略代码部分</h3><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-35-30.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-37-55.png"></p><h3 id="边缘化的因子图表示">边缘化的因子图表示</h3><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-40-11.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-45-53.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-50-06.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-50-25.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-54-13.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-55-20.png"></p><h3 id="边缘化管理器">边缘化管理器</h3><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-43-58.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-59-00.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-10-59-43.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-01-42.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-02-49.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-03-16.png"></p><h3 id="构建边缘化hessian">构建边缘化Hessian</h3><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-04-55.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-06-02.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-07-12.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-07-52.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-08-39.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-23-05.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-24-36.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-26-01.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-27-02.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-28-24.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-29-36.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-30-40.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-32-05.png"></p><p><img src="/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-11-32-16.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vins-mono-后端&quot;&gt;VINS-Mono-后端&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/04/20/VINS-Mono-2-%E5%90%8E%E7%AB%AF/2020-04-20-09-27-54.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>VINS-Mono-1-前端</title>
    <link href="http://yoursite.com/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/"/>
    <id>http://yoursite.com/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/</id>
    <published>2020-04-18T09:10:21.000Z</published>
    <updated>2020-04-20T01:25:19.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vins-mono整体架构">VINS-Mono整体架构</h1><h2 id="架构">架构</h2><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-16-02.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-16-13.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-18-45.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-19-12.png"></p><h2 id="ros基础">ROS基础</h2><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-19-52.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-20-19.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-20-41.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-20-53.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-21-09.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-21-37.png"></p><h2 id="整体代码流程图">整体代码流程图</h2><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-22-12.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-22-24.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-22-37.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-23-11.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-23-48.png"></p><h1 id="前端">前端</h1><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-24-16.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-25-11.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-25-52.png"></p><h2 id="处理图片流程">处理图片流程</h2><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-26-18.png"></p><p>这里的<code>cur_img</code>实际上是上一帧，只是它在这里是这样定义而已。</p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-18-45-56.png"></p><ul><li>假设第一帧跟踪了5个点</li><li>第二帧，跟踪到了0,1,2,4号点，另外有新的特征点5</li><li>可以看到，特征点0,1,2,4同时被第一帧和第二帧观测到，因此被观测次数是2</li><li>...</li></ul><h3 id="直方图均衡化">直方图均衡化</h3><p>代码中是直接调用Opencv函数来处理的，用来增强对比度</p><ul><li>参数越大，对比度越大，噪点越多</li></ul><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-18-47-58.png"></p><h3 id="光流跟踪">光流跟踪</h3><p>也是直接调用Opencv函数</p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-18-48-12.png"></p><h3 id="异常点剔除基础矩阵法">异常点剔除——基础矩阵法</h3><p>也是直接调用Opencv函数</p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-18-53-42.png"></p><h3 id="特征点提取">特征点提取</h3><p>也是直接调用Opencv函数</p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-18-54-44.png"></p><h3 id="前端发布消息">前端发布消息</h3><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-20-31-51.png"></p><h2 id="根据时间戳挑选观测数据">根据时间戳挑选观测数据</h2><p><code>getMeasuments()</code></p><h3 id="挑选策略">挑选策略</h3><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-20-40-33.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-20-38-25.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-20-39-38.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-20-39-14.png"></p><h2 id="前端视觉imu联合优化">前端视觉+IMU联合优化</h2><p>简单来说，就是使用IMU数据来给视觉提供初始位姿，来进行跟踪</p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-20-47-45.png"></p><h3 id="imu预积分">IMU预积分</h3><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-20-53-58.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-21-21-52.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-21-24-22.png"></p><ul><li>根据两帧图像之间的所有IMU数据，来计算IMU约束（预积分）</li><li>然后计算IMU预积分误差<code>residual</code>，下图黄色框部分</li></ul><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-21-25-42.png"></p><p><strong>IMU预积分误差的协方差矩阵</strong></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-21-28-10.png"></p><p><strong>IMU预积分误差协方差更新公式</strong></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-21-29-22.png"></p><p><strong>协方差更新变化过程</strong></p><p>第0帧</p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-21-30-42.png"></p><p>第1帧</p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-21-30-56.png"></p><p>...</p><p>第20帧</p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-21-31-40.png"></p><p><strong>IMU预积分误差的雅可比更新变化过程</strong></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-21-40-10.png"></p><p><img src="/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-21-41-07.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vins-mono整体架构&quot;&gt;VINS-Mono整体架构&lt;/h1&gt;
&lt;h2 id=&quot;架构&quot;&gt;架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/2020/04/18/VINS-Mono-1-%E5%89%8D%E7%AB%AF/2020-04-18-17-16-02.pn
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vins-Mono论文阅读</title>
    <link href="http://yoursite.com/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2020-04-13T07:36:52.000Z</published>
    <updated>2020-04-22T12:51:20.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator">1. VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator</h1><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-13-15-39-05.png"></p><h1 id="摘要">2. 摘要</h1><p>单目VI系统，由单目相机和一个低成本IMU组成，形成6自由度的状态估计器。</p><p>然而，由于单目相机缺乏直接的距离测量，在IMU处理、估计器初始化、外部校准和非线性优化方面提出了重大的挑战。</p><p>在本文，提出了<span class="math inline">\(VINS-Mono\)</span>，一种鲁棒、通用的单目VI状态估计器。</p><p>作者提出的方法从一个鲁棒的处理开始，可用于初始化和故障恢复。通过紧耦合的形式和非线性优化的方法，通过融合的IMU数据预积分和特征观测来获得高精度的VI里程计</p><p>在回环检测模块，结合了紧耦合的公式，使得重定位部分的计算量得以减小</p><p>最后，增加了四个自由度的位姿图优化，以增强全局一致性。</p><p>在公共数据集和真实世界的实验中验证了我们的系统的性能，并与其他最先进的算法进行了比较，我们还在MAV平台上进行了机载闭环自主飞行，并将算法移植到基于ios的演示中，作者强调，所提出的工作是一个可靠、完整和通用的系统，适用于需要高精度定位的不同应用</p><h1 id="介绍">3. 介绍</h1><p>仅使用单目摄像机的方法因其体积小、成本低和易于硬件设置而引起了社区的极大兴趣，然而，单目视觉系统无法恢复度量尺度，因此限制了它们在现实机器人应用中的使用，近年来，我们发现利用低成本惯性测量单元(IMU)来辅助单目视觉系统的发展趋势。</p><p>这种单目视觉惯性系统(VINS)的主要优点是具有可观测的尺度，以及滚转角(roll)和俯仰角(pitch)，这将可以支持需要尺度的状态估计的导航任务</p><p>另外，对IMU测量进行积分，可以通过消除视觉轨迹损失之间的差距来显著提高运动跟踪性能，这些视觉轨迹间隙损失来源于：光度变化、纹理缺乏的场景或者是运动模糊，等等。</p><p>事实上，单目VINS不仅广泛应用于移动机器人、无人机和移动设备，它也是实现充分自我感知和环境感知的最低传感器设置。</p><p>1） 初始化</p><p>然而，这些优点同时也带来一些代价，对于单目VINS，加速度激励是使度量尺度可见的必要条件，<strong>这意味着单目VINS估计器不能从静止状态出发，而是从未知的运动状态出发(意思是: 初始化过程需要有一定的运动)</strong>。同时，我们也认识到视觉惯性系统是高度非线性的，因此在估计初始化方面我们面临着巨大的挑战。另外，由于使用两个传感器，两个传感器的存在也使得相机-IMU的外部标定变得至关重要。</p><p>因此，作者提出VINS-Mono，我们的解决方案从动态的评估器初始化开始，对于故障恢复，也使用同样的初始化模块。</p><p>2） 核心处理</p><p>该方法的核心是一种基于紧耦合滑动窗口非线性优化的VIO方法，单眼VIO模块不仅提供精确的位置、速度和方位估计，它还执行相机-IMU外部校准和IMU偏差的<font color="red">在线标定矫正</font>。</p><p>3） 回环、重定位</p><p>回环检测部分，使用DBOw2，通过与单目VIO进行特征级融合，在紧密耦合的环境中实现重定位功能。这使得重定位所需的计算开销大大减小</p><p>4） 位姿图</p><p>最后，几何验证的回环添加到位姿图，得益于单目VIO的可观察的roll和pitch角，可执行一个四自由度(DOF)位姿图，以确保全局的一致性。</p><p>5） 小结</p><p>与我们之前的工作相比，VINS-Mono的进一步改进包括改进的IMU预集成和偏差校正、紧耦合重定位、全局位姿图优化、广泛的实验评估和健壮的、通用的开源实现</p><p>整个系统功能齐全，使用方便。它已成功地应用于小型AR场景、中型无人机导航和大型状态估计任务，优越的性能已显示出与其他先进的方法。为此，我们总结了我们的贡献如下:</p><ul><li>一个鲁棒的初始化过程，能够从未知的初始状态引导系统</li><li>种紧密耦合的、基于优化的单目视觉惯性测程方法，具有摄像机-IMU外部校准和IMU偏置估计功能</li><li>在线回环检测以及紧耦合的重定位</li><li>四自由度的位姿图优化</li><li>用于无人机导航、大规模定位和移动AR应用的实时性能演示</li><li>与ROS完全集成的PC版本和运行在iPhone6s或以上的iOS系统的开源版本</li></ul><h1 id="relative-work">4. Relative Work</h1><p>。。。</p><h1 id="系统概述">5. 系统概述</h1><p>提出的VI状态估计器如图2所示</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-13-16-15-33.png"></p><p>该系统从测量预处理开始，其中包括<code>特征提取和跟踪</code>，<code>IMU测量之间的两个连续帧预积分</code></p><p>初始化过程(V节提供了所有必要的值，包括姿态、速度、重力向量、陀螺仪偏差和3D特征位置)，用于引导后续基于非线性优化的VIO</p><p>VIO与重定位模块紧密地融合了<code>IMU测量的预积分</code>、<code>特征观测</code>和<code>从回环中重新检测的特征</code></p><p>最后，位姿图优化模块经过采用几何验证的重定位结果，进行全局优化以消除漂移。</p><p>下面是一些角标的定义</p><ul><li><span class="math inline">\((\cdot)^w\)</span>表示世界坐标系(导航坐标系)</li><li>重力g的方向与世界坐标系的z轴对齐，<span class="math inline">\(g^w=[0,0,g]^T\)</span>代表了世界坐标系的重力向量</li><li><span class="math inline">\((\cdot)^b\)</span>是机体坐标系，也定义为IMU的坐标系</li><li><span class="math inline">\((\cdot)^c\)</span>是相机坐标系</li><li>使用旋转矩阵<span class="math inline">\(R\)</span>和哈密顿四元数<span class="math inline">\(q\)</span>来表示旋转(我们主要在状态向量中使用四元数，但旋转矩阵也用于方便地旋转三维向量)</li><li><span class="math inline">\(q_b^w,p_b^w\)</span>代表了从body坐标系到world坐标系的旋转和平移变换</li><li><span class="math inline">\(b_k\)</span>是在第k帧图片的机体坐标系</li><li><span class="math inline">\(c_k\)</span>是在第k帧图片的相机坐标系</li><li><span class="math inline">\(\otimes\)</span>代表了两个四元数之间的乘法运算</li><li><span class="math inline">\((\hat{\cdot})\)</span>用来表示噪声观测或者是不确定性的估计</li></ul><h2 id="测量预处理">5.1. 测量预处理</h2><p>本节介绍惯性和单目视觉测量的预处理步骤：</p><ul><li>对于视觉测量，我们跟踪连续帧之间的特征，并在最新帧中检测新特征</li><li>对于IMU测量，我们预积分两帧之间的数据（注意，我们使用的低成本IMU的测量受到偏差和噪声的影响。因此，我们特别在IMU预积分过程中考虑了bias）</li></ul><h3 id="视觉前端处理">5.1.1. 视觉前端处理</h3><p>对于每一帧新的图像，使用<code>KLT</code>系数光流法来跟踪已有的特征点，同时，会检测新的角点特征，来保持每帧图片中最小的特征点数目在(100~300)之间，该特征点检测器通过设置两个相邻特征之间的最小像素间隔来实现均匀的特征分布。</p><p>首先对二维特征点进行去畸变处理，经过外点去除后将其投影到单位球面上？？ （外点去除采用基础矩阵模型RANSAC处理）</p><p>关键帧选取也在这个步骤中进行，主要根据两条准则来选取</p><ul><li><p>一是与前一帧的平均视差 (如果当前帧和最新关键帧 跟踪到的特征点的平均视差超过了阈值范围，就认为当前帧可作为新的关键帧，需要注意的是，这里不仅仅是平移，旋转也可以导致视差的变化)。另外，如果仅有旋转，那么跟踪得到的特征点无法完成三角化过程，为了避免这种情况，在计算视差时，我们使用陀螺测量的短期积分来补偿旋转。</p><p>注意：这个旋转补偿仅用于关键帧的选取，不包含在VINS公式的旋转项中，最后，尽管IMU角速度测量包含了较大的噪声或者收到bias的影响，这只会导致次优的关键帧选取结果，并不会直接影响最终估计的质量。</p></li><li><p>另外一个准则是: 跟踪质量，如果跟踪的特征点数量低于阈值，那么这一帧会作为新的关键帧，这个标准是为了避免完全丧失特征的情况</p></li></ul><h3 id="imu预积分">5.1.2. IMU预积分</h3><p>IMU预积分首先被[22]提出，使用欧拉角形式对旋转误差进行参数化。</p><p>在我们先前的工作中，提出了一种流形空间的IMU预积分，这使得可以利用连续时间IMU误差状态动态方程推导出协方差传播，然而，先前的工作忽略了IMU的bias的影响，在这篇论文中，我们通过加入IMU偏置校正来扩展我们在之前的工作[7]中提出的IMU预积分。</p><p>IMU的原始角速度和加速度测量值<span class="math inline">\(\hat{w},\hat{a}\)</span>可以表示为如下:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-13-16-57-04.png"></p><p>IMU测量值，是在body系下的，结合了<code>重力</code>，<code>机体的动态</code>，<code>加速度bias</code>，<code>角速度bias</code>，<code>噪声</code>。我们假设，额外的噪声项是高斯噪声，即<span class="math inline">\(n_a \sim \mathcal{N}(0,\sigma_a^2), n_w \sim \mathcal{N}(0,\sigma_w^2)\)</span>。加速度bias和角速度bias使用随机游走模型，也可以使用高斯分布来表示，即<span class="math inline">\(n_{ba}\sim \mathcal{N}(0,\sigma_{ba}^2),n_{bw}\sim\mathcal{N}(0,\sigma_{bw}^2)\)</span>，并且有:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-13-17-03-44.png"></p><p>那么，给定两个图像帧所对应的时刻，可以在时间步<span class="math inline">\([t_k,t_{k+1}]\)</span>内使用IMU测量对<strong>世界坐标系下</strong>的<code>位置</code>，<code>速度</code>和<code>旋转</code>状态进行传播:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-13-17-07-44.png"></p><p>其中，<span class="math inline">\(\Delta t_k\)</span>是<span class="math inline">\([t_k,t_{k+1}]\)</span>的时间间隔</p><p>可以看到，IMU状态传播需要第k帧的的<code>位置</code>，<code>速度</code>和<code>旋转</code>状态。</p><p>当起始状态（即第k帧的<code>位置</code>，<code>速度</code>和<code>旋转</code>）发生变化的时候，我们需要对IMU的测量信息重新传播，即需要重新积分。<strong>这样一来，特别是在基于优化的算法中，每次我们调整姿态时，都需要在它们之间重新传播IMU测量值</strong>，这样的传播策略需要很强的计算能力.</p><p>为了避免这样的重传播情况，我们采用预积分算法：把参考坐标系从<code>world frame</code>变为k时刻的机体坐标系<span class="math inline">\(b_k\)</span>，我们可以得到预积分:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-13-17-15-22.png"></p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-13-17-18-02.png"></p><p>上面的</p><ul><li><span class="math inline">\(R_{w}^{b_{k}}\)</span>: 将数据从世界坐标系转换到k时刻的机体坐标系的旋转变换</li><li><span class="math inline">\(R_{w}^{b_k} p_{b_{k+1}}^{w}\)</span>指的是将k+1时刻在世界坐标系下的机体位置转换到k时刻的机体坐标系<span class="math inline">\(b_k\)</span>后得到的东西</li><li><span class="math inline">\(p_{b_{k+1}}^{w}\)</span>指的是将k+1时刻在世界坐标系下的机体位置</li><li></li><li><span class="math inline">\(R_{w}^{b_k} v_{b_{k+1}}^w\)</span>是k+1时刻在世界坐标系下的机体速度转换到k时刻的机体坐标系<span class="math inline">\(b_k\)</span>后得到的东西</li><li><span class="math inline">\(v_{b_{k+1}}^w\)</span>是k+1时刻在世界坐标系下的机体速度</li><li></li><li><span class="math inline">\(q_{w}^{b_k}\)</span>是k时刻世界坐标系下的机体姿态，也就是从世界坐标系转换到k时刻的机体坐标系的旋转变换</li><li><span class="math inline">\(R_{t}^{b_k}\)</span>是指在<span class="math inline">\([t_k,t_{k+1}]\)</span>内的某个时刻t，机体相对于<code>k时刻的机体坐标系</code>的姿态，即表示<code>从时刻</code> <span class="math inline">\(t \in [t_k,t_{k+1}]\)</span>到<code>k时刻的机体坐标系</code>的旋转变换</li><li></li><li><span class="math inline">\(\alpha_{b_{k+1}}^{b_{k}}\)</span>指相对于k时刻机体坐标系的位置积分，即这个位置积分量是在<code>k时刻的机体坐标系</code><span class="math inline">\(b_{k}\)</span>下的</li><li><span class="math inline">\(\beta_{b_{k+1}}^{b_{k}}\)</span>指相对于k时刻机体坐标系的速度积分，即这个速度积分量是在<code>k时刻的机体坐标系</code><span class="math inline">\(b_{k}\)</span>下的</li></ul><p>可以看到，通过改变参考坐标系为<code>第k帧的机体坐标系</code><span class="math inline">\(b_k\)</span>，可以使得这些预积分项<span class="math inline">\(\alpha,\beta,\gamma\)</span>基本上只与IMU的测量有关，与第k帧的<code>位置</code>，<code>速度</code>和<code>旋转</code>无关，</p><p>即<span class="math inline">\(\alpha_{b_{k+1}}^{b_k},\beta_{b_{k+1}}^{b_k},\gamma_{b_{k+1}}^{b_k}\)</span>与IMU的偏置<span class="math inline">\(b_{at},b_{wt}\)</span>有关，然而这个偏置变化一般较小，如果变化了，我们可以使用一阶近似，然后重新计算预积分，否则，预积分只需计算一次就可以了{<font color="red">这里说的操作，对应于式(12)</font>}</p><p>这个预积分策略大大减少了运算量，因为这样使得不需要每次更新完状态之后都重新传播IMU的测量</p><p><strong>对于离散时间实现</strong></p><p>对于离散时间，有不同的数值积分方法，如欧拉法，中点法，RK4法等等，<strong>在这里，选择了欧拉法进行推导</strong>，方便理解(<strong>实际代码中，使用了中点法积分</strong>)</p><p>在预积分起始时刻，即<span class="math inline">\([t_k,t_{k+1}]\)</span>中的<span class="math inline">\(t_k\)</span>时刻，<span class="math inline">\(\alpha_{b_k}^{b_k},\beta_{b_k}^{b_k}\)</span>都是零，而<span class="math inline">\(\gamma_{b_k}^{b_k}\)</span>则是单位四元数，因为还没有开始积分</p><p>那么，<span class="math inline">\(\alpha,\beta,\gamma\)</span>的均值根据下面的步骤来进行传播，(需要注意的是，噪声项<span class="math inline">\(n_a,n_w\)</span>是未知的，置为0)，这产生了预积分项的估计值，使用<span class="math inline">\((\hat{\cdot})\)</span>来表示:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-13-18-09-51.png"></p><p>其中，</p><ul><li><span class="math inline">\(i\)</span>表示在<span class="math inline">\([t_k,t_{k+1}]\)</span>时间段内的离散化时刻，(即两帧图像之间有很多个时刻的IMU测量值)</li><li><span class="math inline">\(\delta t\)</span>是IMU测量间隔</li></ul><p>然后，我们需要处理协方差的传播，因为4自由度的旋转四元数<span class="math inline">\(\gamma_{t}^{b_k}\)</span>是超参数化的，我们定义其误差项为 <strong>在其均值附近的一个小扰动</strong>:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-13-18-13-21.png"></p><p>其中，<span class="math inline">\(\delta \theta_t^{b_k}\)</span>是三维的小扰动</p><p>因此，可以推导出连续时间下，关于式(6)的误差项进行线性化之后的动态方程:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-13-18-22-57.png"></p><p><font color="red">这里，有点跟<a href="http://epsilonjohn.club/2020/03/21/%E5%9B%9B%E5%85%83%E6%95%B0%E7%9A%84%E7%8A%B6%E6%80%81%E8%AF%AF%E5%B7%AE%E5%8D%A1%E5%B0%94%E6%9B%BC-Quaternion-kinematics-for-the-error-state-KF/" target="_blank" rel="noopener">误差状态卡尔曼</a> 类似，具体见里面的式(166)</font></p><p><span class="math inline">\(P_{b_{k+1}}^{b_k}\)</span>可以使用离散时间的一阶近似进行递归计算得到，初始化协方差<span class="math inline">\(P_{b_{k}}^{b_k}=0\)</span>:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-13-18-29-07.png"></p><p>其中，Q是关于噪声项<span class="math inline">\((\sigma_{\alpha}^2,\sigma_{w}^2,\sigma_{b_a}^2,\sigma_{b_w}^2)\)</span>对角型的协方差矩阵</p><p>同时，关于预积分误差项<span class="math inline">\(\delta z_{b_{k+1}}^{b_k}\)</span>分别对于预积分误差项<span class="math inline">\(\delta z_{b_{k}}^{b_k}\)</span>的一阶雅克比<span class="math inline">\(J_{b_{k+1}}\)</span>，也可以使用初始化的雅克比<span class="math inline">\(J_{b_k}=I\)</span>进行递归计算得到，即:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-13-18-33-08.png"></p><p>使用递归公式，我们可以得到协方差矩阵<span class="math inline">\(P_{b_{k+1}}^{b_k}\)</span>，以及雅克比<span class="math inline">\(J_{b_{k+1}}\)</span></p><p><span class="math inline">\(\alpha_{b_{k+1}}^{b_k},\beta_{b_{k+1}}^{b_k},\gamma_{b_{k+1}}^{b_k}\)</span>相对于bias的一阶近似可以写成:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-13-19-18-51.png"></p><p>其中，</p><ul><li><span class="math inline">\(J_{b_a}^\alpha\)</span> 是<span class="math inline">\(J_{b_{k+1}}\)</span>的子块，其位置与<span class="math inline">\(\frac{\delta \alpha_{b_{k+1}}^{b_k}}{\delta b_{a_{k}}}\)</span>相对应</li><li>对于<span class="math inline">\(J_{b_w}^\beta,J_{b_a}^\beta,J_{b_{w}}^\beta,J_{b_{w}}^\gamma\)</span>也同样</li></ul><p>当bias的估计发生轻微变化时，我们使用(式12)来矫正预积分的结果，而不是使用重新传播的方式。</p><p>现在，我们可以写成IMU测量<font color="red">(预积分)</font>模型以及对应的协方差矩阵<span class="math inline">\(P_{b_{k+1}}^{b_k}\)</span></p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-13-19-25-03.png"></p><p><strong>实际上，这里就是将(式5)关于预积分项移到等式左侧，其他移到右侧，得到的结果</strong></p><h2 id="初始化">5.2. 初始化</h2><p>单目紧耦合的VI里程计是高度非线性系统，因为尺度不能直接从单目相机中获取，因此如果没有很好的初始化值，很难直接对两种测量信息进行融合。</p><p>一方面可能会假设一个静止的初始条件来启动VINS估计器，然而，这种假设是不恰当的，由于运动下的初始化是经常遇到的现实世界的情况。当IMU的测量收到大的bias影响的时候，这种情况变得更加复杂。</p><p>实际上，对于单目VINS，初始化通常式最脆弱的步骤，系统的可行性需要一个鲁棒的初始化处理。</p><p>采用了紧耦合的传感器融合方法来获取初始值，我们发现，仅仅使用视觉的SLAM，或者是Sfm，初始化具有一个好的属性。在大多情况下，visual-only的系统可以通过相对运动关系方法如<code>八点法</code>、<code>五点法</code>或者是估计单应矩阵H，来进行初始化。</p><p>通过使用visual-only Sfm的结果来对齐IMU预积分，我们可以粗略的恢复出<code>尺度</code>、<code>重力</code>、<code>速度</code>、甚至是<code>bias</code>，这对于单目VINS的初始化而言已经足够了，如图4所示。</p><p>与文献[17]相反，在初始化阶段，其同步估计角速度和加速度的bias。而我们选择在初始化阶段，忽略加速度的bias。加速度的bias与重力耦合在一起，相对于较大的重力向量，小量的平台的动态在这个初始化阶段，这些bias项很难被观测到。</p><h3 id="滑动窗口vision-only-sfm">5.2.1. 滑动窗口：Vision-Only SFM</h3><p>初始化处理的开始阶段：先使用vision sfm来估计相机的pose和特征点的position</p><p>为了降低运算的复杂度，我们保持一个有界的滑动窗口。首先，我们检查最新的一帧与之前的所有帧的特征点的相关性。如果我们在最新的一帧与滑动窗口中的任意一帧中，可以找到稳定的特征点跟踪(more than 30 tracked features)同时，视差足够大(大于 20 个 rotation-compensated pixels)。我们使用<code>五点法</code>来恢复出这两帧之间的相对旋转和平移量[文献33]。否则，我们我们保存最新一帧在滑动窗口中，等待其他新的一帧到来。</p><p>如果五点法计算成功，我们设置一个任意的尺度，然后对两帧之间的特征点关联进行三角化，然后基于这些三角化得到的特征点(三角化变成了3D点)，对滑动窗口内的其他帧使用PnP算法来估计出滑窗内其他帧的位姿估计。</p><p>最后，使用global BA来进行优化，以最小化所有特征点的重投影误差。因为我们没有任何关于世界坐标系的先验知识，因此我们设置第一帧的相机坐标系作为sfm的参考坐标系<span class="math inline">\((\cdot)^{C_0}\)</span>，所有帧的位姿<span class="math inline">\((\bar{p}_{C_k}^{C_0},q_c^b)\)</span>以及特征点都是相对于坐标系<span class="math inline">\((\cdot)^{C_0}\)</span>而言的。假设我们有一个粗略的关于机体坐标系和相机坐标系的外参<span class="math inline">\((p_c^b,q_c^b)\)</span>，我们可以把每一帧的相机坐标系转换为机体坐标系:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-14-14-40-31.png"></p><p>其中，<span class="math inline">\(s\)</span>是以米为单位的尺度因子，求解尺度参数是成功初始化的的关键</p><h3 id="vi对齐">5.2.2. VI对齐</h3><h4 id="gyro-bias标定">5.2.2.1. Gyro Bias标定</h4><p>考虑滑动窗口中连续的两帧的机体坐标系<span class="math inline">\(b_k,b_{k+1}\)</span>，我们从视觉的SFM中可以获得这两帧机体坐标系相对于参考坐标系的旋转<span class="math inline">\(q_{b_k}^{c_0},q_{b_{k+1}}^{c_0}\)</span>，另外，我们可以从IMU预积分数据中获取这两个图像帧之间的预积分约束<span class="math inline">\(\hat{\gamma}_{b_{k+1}}^{b_k}\)</span>，我们对IMU预积分项相对于gyro bias参数进行线性化，然后最小化下面的损失函数:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-14-14-47-21.png"></p><p>其中</p><ul><li><span class="math inline">\(\mathcal{B}\)</span>是滑动窗口中所有帧的集合</li><li>通过使用前面推导的bias雅克比，我们有<span class="math inline">\(\hat{\gamma}_{b_{k+1}}^{b_k}\)</span>关于gyro bias的一阶近似</li><li>在这种方式下，我们获得了关于gyro bias的初始标定</li><li>然后我们使用新的gyro bias值，对IMU的预积分项<span class="math inline">\(\alpha_{b_{k+1}}^{b_k},\beta_{b_{k+1}}^{b_k},\gamma_{b_{k+1}}^{b_k}\)</span>进行重传播</li></ul><h4 id="速度重力向量尺度的初始化">5.2.2.2. 速度、重力向量、尺度的初始化</h4><p>在gyro bias初始化完成之后，我们进一步初始化其他状态，定义这些状态为:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-14-14-53-24.png"></p><p>其中:</p><ul><li><span class="math inline">\(v_{b_k}^{b_k}\)</span>是在机体坐标系<span class="math inline">\(b_k\)</span>的速度</li><li><span class="math inline">\(g^{c_0}\)</span>是在参考坐标系<span class="math inline">\(c_0\)</span>坐标系的重力向量</li><li><span class="math inline">\(s\)</span>是单目sfm的尺度参数，以米为单位</li></ul><p>考虑两个连续的坐标系<span class="math inline">\(b_k,b_{k+1}\)</span>，把(式5)中的世界坐标系换成参考坐标系<span class="math inline">\((\cdot)^{c_0}，\)</span>那么(式5)可以写成如下形式:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-14-14-57-53.png"></p><p>我们可以结合(式14)和(式17)到如下线性测量模型:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-14-14-58-47.png"></p><p>可以看到，</p><ul><li><span class="math inline">\(R_{b_{k}}^{c_0},R_{b_{k+1}}^{c_0},\bar{p}_{c_k}^{c_0},\bar{p}_{c_{k+1}}^{c_0}\)</span>都是从单目sfm中获取到的值</li><li><span class="math inline">\(\Delta t\)</span>是两个连续图像帧之间的时间间隔</li></ul><p>通过求解如下线性最小二乘:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-14-15-01-31.png"></p><p>我们可以获取每一帧的机体坐标系的速度，以及在参考坐标系<span class="math inline">\((\cdot)^{c_0}\)</span>的重力向量以及尺度参数</p><h4 id="重力对齐">5.2.2.3. 重力对齐</h4><p>通过量级的约束，可以对原线性初始化步骤(即上面的步骤)得到的重力矢量进行修正。</p><p>在大多情况下，重力向量的量级是已知的，这会导致重力向量仅有2自由度，因此，我们对重力向量在其正切空间使用2个变量来重新参数化</p><p>我们的参数化使用<span class="math inline">\(g\cdot \bar{\hat{g}}+w_1 b_1 +w_2b_2\)</span>来表示重力向量</p><p>其中</p><ul><li><span class="math inline">\(g\)</span>是已知重力的量级</li><li><span class="math inline">\(\bar{\hat{g}}\)</span>是代表重力方向的单位向量</li><li><span class="math inline">\(b_1,b_2\)</span>是两个正交基章程的正切平面，如图5所示</li><li><span class="math inline">\(w_1,w_2\)</span>是对应于<span class="math inline">\(b_1,b_2\)</span>两个基的位移</li></ul><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-14-15-12-14.png"></p><p>使用下面的算法1进行叉乘，我们可以找到<span class="math inline">\(b_1,b_2\)</span>，然后我们将(式17)中的重力向量<span class="math inline">\(g\)</span>使用<span class="math inline">\(|g|\cdot \bar{\hat{g}}+w_1 b_1 +w_2b_2\)</span>来替换，然后求解<span class="math inline">\(w_1,w_2\)</span>以及其他变量，迭代至收敛</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-14-15-15-58.png"></p><h4 id="完成初始化">5.2.2.4. 完成初始化</h4><p>对重力矢量的修正之后，我们可以通过旋转重力向量到z轴来得到世界坐标系和参考坐标系<span class="math inline">\(c_0\)</span>之间的旋转<span class="math inline">\(q_{c_0}^{w}\)</span></p><p>然后我们将参考坐标系<span class="math inline">\((\cdot)^{c_0}\)</span>中的<strong>所有变量</strong>旋转到世界坐标系<span class="math inline">\((\cdot)^w\)</span>中，机体坐标系的速度也被转换到世界坐标系中。</p><p>视觉SfM的平移分量将缩放为以米为单位，此时，初始化过程已经完成，所有这些度量值将被提供给一个紧耦合的单目VIO</p><h2 id="紧耦合vio">5.3. 紧耦合VIO</h2><p>在估计器初始化之后，我们使用基于滑动窗口的紧耦合单目VIO进行高精度和稳健的状态估计，如图3所示</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20200414214807817.png"></p><h3 id="系统状态">5.3.1. 系统状态</h3><p>滑动窗口内全部状态向量定义如下:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20200414214957557.png"></p><p>其中，</p><ul><li><span class="math inline">\(x_k\)</span>是IMU在第k帧图像对应的时刻的状态，包含了IMU（机体）在世界坐标系下的位置、速度和姿态，以及在机体坐标系下的IMU加速度bias和角速度bias</li><li>n表示所有的关键帧数量</li><li>m表示滑动窗口内所有的特征点的数量</li><li><span class="math inline">\(\lambda_l\)</span>表示第l个特征点相对于其<strong>第一次观测</strong>的逆深度值</li></ul><p>我们的目标是最小化关于以下3个部分的和：</p><ul><li>先验项</li><li>视觉重投影残差项</li><li>IMU预积分残差项</li></ul><p>即目标函数如下所示:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/image-20200414215722891.png"></p><p>其中，</p><ul><li><span class="math inline">\(r_{B}(\hat{z}_{b_{k+1}}^{b_k},X)\)</span>表示IMU的测量残差</li><li><span class="math inline">\(r_c(\hat{z}_{l}^{c_j},X)\)</span>表示视觉测量残差</li><li><span class="math inline">\({B}\)</span>是IMU测量数据的集合</li><li><span class="math inline">\({C}\)</span>是当前滑动窗口中至少被观测到两次或以上的特征点集合</li><li><span class="math inline">\({r_p,H_p}\)</span>是来自<code>边缘化</code>得到的先验信息</li><li>我们采用了Google的Ceres优化库来求解这个非线性问题</li></ul><h3 id="imu测量误差">5.3.2. IMU测量误差</h3><p>考虑滑动窗口中两个连续的图像帧时刻所对应的机体坐标系<span class="math inline">\(b_k,b_{k+1}\)</span>，根据(式13)定义的IMU测量模型，可以得到IMU的预积分參差如下:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-15-10-20-57.png"></p><p>其中,</p><ul><li><span class="math inline">\([\cdot]_{xyz}\)</span>提取四元数中的角度部分，作为误差状态的表达，即<span class="math inline">\(\delta\theta_{b_{k+1}}^{b_k}\)</span>是关于四元数的误差状态</li><li><span class="math inline">\([\hat{\alpha}_{b_{k+1}}^{b_k},\hat{\beta}_{b_{k+1}}^{b_k},\hat{\gamma}_{b_{k+1}}^{b_k}]^T\)</span>是关于IMU的在两个图像帧之间的预积分项，这一项仅与包含噪声的加速度和角速度测量有关</li><li>加速度计和陀螺仪的bias被包含在參差项中，用以实现在线的矫正</li></ul><h3 id="视觉测量误差">5.3.3. 视觉测量误差</h3><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-15-11-03-10.png"></p><p>与传统的针孔相机模型(在广义成像平面上定义投影误差)相反，我们在一个单位球面上定义了相机的测量误差，原因是几乎所有类型的照相机，包括广角照相机、鱼眼照相机和全向照相机，其光学特性都可以被模拟成以单位球面为单位的射线。</p><p>考虑第l个特征的第一次被第i帧图像观测到，那么在第j帧再次观测到这个特征点时，可以建立如下视觉残差：</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-15-10-35-04.png"></p><p>其中，</p><ul><li><span class="math inline">\([u_l^{c_i},v_l^{c_i}]\)</span>表示第l个特征的第一次被第i帧图像观测所在的像素位置</li><li><span class="math inline">\([u_l^{c_j},v_l^{c_j}]\)</span>表示第l个特征被第j帧图像观测所在的像素位置</li><li><span class="math inline">\(\pi_c^{-1}\)</span>表示使用相机模型的内参，将像素点坐标反投影成一个单位向量（3D点）</li><li><span class="math inline">\(P_l^{c_j}\)</span>用于(式22)，是在正切空间中一个固定长度的标准协方差</li><li><span class="math inline">\(\hat{\bar{\mathcal{P}}}_l^{c_j}\)</span>是将<code>第j帧</code>观测到第l个特征点的像素坐标反投影得到的3D向量</li><li><span class="math inline">\(\mathcal{P}_l^{c_j}\)</span>是将<code>第i帧</code>观测到第l个特征点的像素坐标 1）先反投影成3D向量(归一化平面上的) 2）再利用逆深度，得到在第i帧相机坐标系下的3D点 3）然后根据IMU和相机的外參，将该3D点变换到IMU坐标系下 4）根据(第i帧)待估计的机体位姿<span class="math inline">\(T_{b_i}^{w}\)</span>，将该点变换到世界坐标系下 5）根据(第j帧)待估计的机体位姿<span class="math inline">\([T_{b_j}^{w}]^{-1}\)</span>，将该点投影到第j帧机体坐标系下 6）然后，再次根据IMU和相机外參，将该点转换到第j帧的相机坐标系下</li></ul><p>因为视觉參差的自由度是2,我们将參差向量投影到正切空间。<span class="math inline">\(b_1,b_2\)</span>是在正切平面<span class="math inline">\(\hat{\bar{\mathcal{P}}}_l^{c_j}\)</span>上的两个任意选择的正交基，如图6所示。我们可以使用之前提到的算法1来找到其中的一组<span class="math inline">\(b_1,b_2\)</span></p><h3 id="边缘化">5.3.4. 边缘化</h3><p>为了控制基于优化方法的VIO的计算复杂度，采用了边缘化的方法。</p><p>我们选择性地对弹出滑动窗口的机体状态<span class="math inline">\(x_k\)</span>和特征点<span class="math inline">\(\lambda_l\)</span>进行边缘化，然后将它们的测量信息转化为对应的边缘化信息，作为先验</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-15-11-03-49.png"></p><p>如图7所示，当有新的一帧到来时，首先判断最新的一帧是否为关键帧：</p><ul><li>如果是关键帧，那么将其插入到滑动窗口中，同时，弹出滑动窗口中排在最前面（最old的）的那一帧，并且对其视觉和IMU测量信息进行边缘化，转化为先验矩阵<span class="math inline">\(H_{prior}\)</span></li><li>如果不是关键帧，那么对于这个最新的一帧，不插入到滑动窗口中，并且舍弃其视觉信息，保留IMU的测量信息（因为需要其预积分信息来进行向前推算）</li></ul><p>关键帧选取+边缘化策略是为了保持滑动窗口中的关键帧保持一定的空间分布，这确保了足够的视差来对特征点进行三角化，并且使得加速度计测量值保持在一个较大的激励下的概率更大。</p><p>边缘化的实施采用的是<code>Schur complement</code>，我们基于所有与被移除状态相关的边缘化属性来构建一个新的先验，然后新的先验与旧的先验相加。</p><h3 id="motion-only-ba">Motion-only BA</h3><p>对于移动终端等计算能力较低的设备，由于非线性优化的计算量较大，紧耦合单目VIO系统无法达到相机帧率的输出。为了达到这个目的，我们使用了一个轻量级的Motion-only的视觉惯性BA来使得状态估计可以达到相机速率(30赫兹)</p><p>损失函数与之前定义的单目VIO损失函数一样(式22)，但是，相比与之前对全部状态进行优化，在这里我们只优化了固定数目的IMU（机体）状态的位姿和速度，把特征点深度、IMU和相机外參、bias、以及旧的IMU(机体)状态等这些看作是固定不变的常量。</p><p>我们使用所有的视觉和惯性测量来进行这个Motion-only的BA优化，这个结果比直接对最新一帧使用Pnp（前端跟踪）算法更加平滑。</p><p>图8给出了该策略的实例</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-15-14-55-08.png"></p><p>与全状态紧耦合的单目VIO(在最先进的嵌入式计算机上可能需要50ms)相比，Motion-only的视觉-惯性BA优化只需要大约5ms的时间</p><h3 id="imu状态估计的正向传播">IMU状态估计的正向传播</h3><p>虽然我们的VIO的频率受限于图像捕获频率，但我们仍然可以直接使用IMU的测量数据来对最新的VIO状态估计进行传递。</p><p>高频状态估计值可用于闭环的状态反馈，后面提出了一种基于这IMU-rate状态估计的自主飞行实验</p><h3 id="故障诊断和恢复">故障诊断和恢复</h3><p>尽管提出的VIO对于挑战环境和运动下可以保持一定的鲁棒性。但是由于强烈的光照变化或剧烈的运动等情况下，故障还是不可避免的发生。主动故障检测与恢复策略可以提高系统的实用性，故障检测模块是一个独立于状态估计器的模块，用来检测估计器的异常输出，检测异常有如下准则:</p><ul><li>在最新帧中被跟踪的特征数小于某个阈值</li><li>估计器的最后两次输出（位置、姿态）有较大的不连续性</li><li>bias或外參估计产生了较大的变化</li></ul><p>一旦检测出异常，系统将切换回初始化阶段，一旦单目VIO重新初始化完成，将会重新创建新的一段pose Graph</p><h2 id="重定位">重定位</h2><p>我们的滑动窗口和边缘化方案控制了计算复杂度，但也为系统引入了累积漂移。更具体地说，漂移发生在全局的3D位置(x, y, z)和绕重力方向(yaw)旋转，VIO（4自由度不可观）</p><p>为了消除漂移，提出了一种可以与单目VIO状态估计器无缝整合的紧耦合重定位模块，重定位首先启动回环检测模块，用来检测该环境是否曾经探查过，然后建立回环候选关键帧和（最新）当前帧之间的特征级的关联，这些特征关联被紧密地整合到单目VIO模块中，以此来实现零漂移的状态估计。</p><p>多个观测值的多重特征直接用于重定位，获得了更高的精度和更好的状态估计平滑度，重定位的处理过程如图9(a)所示。</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-15-15-25-22.png"> <img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-15-15-26-02.png"></p><h3 id="回环检测">回环检测</h3><p>我们使用<code>DBoW2</code>，一种词袋模型，用于回环检测中。除了单目VIO模块中检测到的角点特征外，还有500个以上的额外角点被检测到，并使用BRIEF描述子进行描述。额外的角特征用于在循环检测时实现更好的召回率。</p><p>将描述符作为视觉描述单词来查询视觉数据库，经过时间和几何一致性检查后，<code>DBoW2</code>将返回回环候选帧。我们对所有特征点保留所有BRIEF描述符，但丢弃原始图像以减少内存消耗。</p><p>我们注意到我们的单眼VIO能够渲染roll和pitch可观，因此，我们不需要依赖于旋转不变的特性，比如ORB_SLAM中使用的ORB特征点</p><h3 id="特征恢复">特征恢复</h3><p>当检测到一个回环时，通过恢复特征关联，建立起当前滑动窗口和闭环候选帧之间的连接，特征关联采用BRIEF描述符进行匹配来完成。直接的描述符匹配可能会产生大量的外点，为了解决这个问题，我们采用两步骤的外点去除，如图10所示</p><ul><li>2D-2D： 使用RANSAC进行基础矩阵F的测试，对当前帧图像的2D观测点与回环候选帧图像（实际上是特征点）进行基础矩阵F测试</li><li>3D-2D： 使用RANSAC的PnP测试，基于当前滑动窗口中已知的3D点，以及回环候选帧图像中的2D特征点，进行PnP测试</li></ul><p>当两个测试的内点数达到一定阈值的时候，我们认为这个回环候选帧就是正确的回环，然后进行重定位。</p><h3 id="紧耦合的重定位">紧耦合的重定位</h3><p>重定位处理可以有效地对齐当前由单目VIO维护的滑动窗口到过去的位姿。重定位过程中，我们把所有闭环关键帧的位姿都作为约束，然后使用<code>所有的IMU测量值</code>、<code>局部视觉测量值</code>和从<code>回环检索到的特征关联</code>来共同优化当前滑动窗口</p><p>根据回环检测得到的回环帧<span class="math inline">\(v\)</span>与当前帧的特征关联，我们可以写出视觉误差项，与前面VIO模块中的(式25)一致，唯一不同的是，回环帧的位姿<span class="math inline">\((\hat{q}_v^{w},\hat{p}_v^w)\)</span>可以从pose Graph中获取，或者是直接使用过去的里程计输出（如果这是第一次重定位的话），并且回环帧的位姿<span class="math inline">\((\hat{q}_v^{w},\hat{p}_v^w)\)</span>作为常数对待，不参与优化，只提供约束。</p><p>为了实现紧耦合的重定位，我们可以用附加的闭环约束对式(22)中的非线性目标函数稍作修改，得到:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-15-16-02-58.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathcal{L}\)</span>是从闭环关键帧与当前滑动窗口恢复出来的特征关联的集合</li><li><span class="math inline">\((l,v)\)</span>表示在闭环关键帧中观测到的第l个特征点</li></ul><p>需要注意的是，尽管目标函数与(式22)稍有不同，但是待求解的状态量的维度是一样的，这是因为闭环关键帧的位姿作为常数处理</p><p>如果当前滑动窗口建立起多个闭环时，我们同时使用全部的闭环帧的特征关联来进行优化。这为重新定位提供了多视图约束，提高了精度和平滑度</p><p><strong>注意</strong></p><p>这里的优化都是针对于当前滑动窗口的优化，对于过去的位姿、闭环关键帧位姿的全局优化，在下一节进行讨论。</p><h2 id="全局pose-graph优化">全局Pose Graph优化</h2><p>重定位后，当前滑动窗口，将与过去的位姿进行对齐，减少漂移。利用重定位的结果，这一步额外的Pose Graph优化步骤是用于确保过去的位姿拥有较好的全局一致性。</p><p>因为我们的VI处理中，roll和pitch是可观的（相对于世界坐标系-ENU或其他），那么累积漂移只会发生在其余四个自由度（3D位置、沿重力方向旋转的yaw角）。</p><p>为了解决这个问题，我们忽略不产生漂移的roll和pitch状态量，然后只进行一个4自由度的Pose Graph优化</p><h3 id="向pose-graph中添加关键帧">向Pose Graph中添加关键帧</h3><p>当一个关键帧从滑动窗口中被边缘化掉的时候，它将被插入到Pose Graph里面，这个关键帧在这个Pose Graph里面作为一个顶点，然后它可以使用两种类型的边来连接其他顶点：</p><ul><li><p>序列边：一个关键帧会与之前的几个关键帧建立起一些<code>sequential edge</code>（序列边）。一条序列边代表了两个关键帧的相对变换关系，这个相对变换可以直接从VIO获取，考虑一个较的关键帧i和其前一帧j，那么这个序列边仅仅包含相对位置<span class="math inline">\(\hat{p}_{ij}^i\)</span>和相对yaw角<span class="math inline">\(\hat{\psi}_{ij}\)</span>:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-15-16-28-33.png"></p></li><li><p>回环边：如果这个被边缘化的关键帧与之前的回环帧建立了回环连接，那么这个回环连接同样被加入到Pose Graph中。相似的，回环边也仅仅包含4自由度的相对关系，如上面的(式27)所示，这个回环边的数据来自重定位得到的结果</p></li></ul><h3 id="自由度的pose-graph优化">4自由度的Pose Graph优化</h3><p>我们定义连接着关键帧i和关键帧j的边所代表的残差如下:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-15-16-32-54.png"></p><p>其中，</p><ul><li><span class="math inline">\(\hat{\phi}_i,\hat{\theta}_i\)</span>分别是roll和pitch的估计值，可以直接从单目VIO状态估计器中直接获取</li></ul><p>那么，对于Pose Graph中的所有边（序列边、回环边），可以构建出如下损失函数:</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-15-16-37-38.png"></p><p>其中</p><ul><li><span class="math inline">\(\mathcal{S}\)</span>代表所有序列边</li><li><span class="math inline">\(\mathcal{L}\)</span>代表所有回环边</li></ul><p>虽然紧耦合重定位模块有助于消除错误的闭环，但是对于<code>回环边</code>，我们仍添加Huber正则项<span class="math inline">\(\rho(\cdot)\)</span>进一步减少可能错误的闭环所带来的影响。</p><p>相反的是，对于<code>序列边</code>，我们不使用鲁棒性核函数，因为这些边是从紧耦合VIO状态估计模块中来的，已经经过外点去除，满足内点条件了。</p><p>位姿图优化和重定位模块在两个单独的线程中异步进行，这使得可以在任何时候使用最优化的位姿图进行重定位。同样，即使当前位姿图优化尚未完成，也可以使用现有的（旧的）位姿图进行重定位，这个过程如图9(b)所示。</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-15-16-43-42.png"></p><h3 id="pose-graph管理">Pose Graph管理</h3><p>当行驶距离增加时，位姿图的大小可能会一直增大，从而限制了系统的长期实时性，为了解决这个问题，我们实现了一个降采样的过程，以保持Pose Graph数据库在限制的大小范围。</p><p>所有具有闭环约束的关键帧都将保留，而其他要么太接近要么与它的邻居有相似方向的关键帧则可能被删除，关键帧被移除的概率与它的邻居的空间密度成正比。</p><h2 id="实验">实验</h2><p>作者进行了3个实验以及两个应用来测试所提出的VINS-Mono系统。</p><p>在第一个实验中，在公共数据集上进行测试，对比了提出的方法和其他先进方法的性能，然后进行数值分析，展示提出系统的准确性。</p><p>然后，在室内环境中测试系统，以评估在重复场景中的性能</p><p>最后进行了大规模的实验，验证了系统的长期实用性。</p><p>此外，我们将所提出的系统应用于两个应用。对于无人机的应用，我们使用VINS-Mono进行位置反馈，以控制无人机跟随预定的轨迹。然后我们将我们的方法移植到一个iOS移动设备上，并与Google Tango进行比较</p><h3 id="公开数据集测试对比">公开数据集测试对比</h3><p>使用<code>EuRoC</code>MAV的视觉-惯性数据集来评估提出的VINS-Mono系统，这个数据集由无人机的板载立体相机(Aptina MT9V034 global shutter, WVGA monochrome, 20FPS)和同步IMU（ADIS16448, 200Hz），以及真值数据组成。在测试的时候，只采用左相机的图像，在这些数据中可以观测到较大的IMU bias以及光照变化。</p><p>在这个实验中，我们比较了VINS-Mono和OKVIS（一种支持单目、双目的先进方法）算法，<code>OKVIS</code>也是一种基于滑动窗口优化的算法，本文提出的<code>VINS-Mono</code>和<code>OKVIS</code>在很多细节上不一样，我们的系统完整的，具有鲁棒的初始化和回环检测。</p><p>实验使用两个数据序列，分别是:</p><ul><li>MH_03_median</li><li>MH_05_difficult</li></ul><p>为了方便描述，采用如下符号简化描述</p><ul><li><code>VINS</code>表示仅仅是VIO（视觉-惯性里程计）(没有回环部分)</li><li><code>VINS_loop</code>表示带有完整版的重定位和位姿图优化的VINS</li></ul><p>为了公平对比，我们采取丢弃头100个输出，然后使用接下来的150个输出来与真值进行对齐，然后比较接下来的输出。</p><p>对于MH03序列，其轨迹如图11所示</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-20-22-34-09.png"></p><p>我们仅仅比较平移误差，因为在这个序列中，旋转运动是微不足道的。</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-20-22-39-10.png"></p><p>如图所示，<code>VINS_loop</code>的平移误差最小</p><p>对于MH05序列，也可以观察到近似的结果，</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-20-22-40-57.png"> <img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-20-22-41-10.png"></p><p>由于在这个序列中运动平稳，偏航角变化不大，所以基本上只发生位置漂移，显然，具有回环功能的方法消除了大部分的漂移。</p><p>在<code>roll</code>和<code>pitch</code>角的估计上，<code>OKVIS</code>的估计更加准确一些，一个可能的原因是VINS-Mono使用的预积分，这是使用一阶近似来进行IMU的传播，以节省计算资源。</p><p>对于单纯的VIO, VINS-Mono和OKVIS都有相似的Accuracy，很难区分哪一个更好然而，VINS-Mono在系统级别上优于OKVIS，因为VINS-Mono是一个完整的系统，具有鲁棒的初始化和闭环模块，可以辅助单目VIO</p><h3 id="室内环境对比">室内环境对比</h3><p>在室内实验中，我们选择实验室环境作为实验区域，使用的设备如图15所示</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-20-22-48-10.png"></p><p>我们用手拿着传感器，在实验室里以正常的速度行走，在实验过程中，我们遇到行人，低光照条件，纹理缺乏的区域，玻璃反射区域，如图16所示，在多媒体附件中可以找到该视频。</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-20-22-49-51.png"></p><p>我们与<code>OKVIS</code>进行了对比，如图17所示</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-20-22-51-22.png"></p><h3 id="大范围环境测试">大范围环境测试</h3><h4 id="实验室外面">实验室外面</h4><p>我们对VINS-Mono在室内外混合场景下进行了测试，这些传感器套装与图15所示的设备一样。</p><p>我们从实验室的一个座位出发，然后我们下了楼梯，绕着大楼外面的操场走，接下来，我们回到大楼，上了楼，最后，我们回到了实验室的同一个座位上。</p><p>整个轨迹超过700米，持续接近10分钟，这个实验的视频可以在附件的多媒体中找到。</p><p>轨迹如图19所示，</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-20-22-55-58.png"></p><p>在提出的方法中，可以看到，楼梯的形状是清晰的。最终，将闭环轨迹与Google地图进行比对，验证其准确性，如图18所示</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-20-22-58-01.png"></p><p>OKVIS的最终漂移是[13.80，-5.26，7.23]米，分别在x、y和z轴上。无回环的VINS-Mono的最终漂移是[-5.47, 2.76,-0.29]米，其占轨迹长度的0.88%，小于OKVIS的2.36%，带有回环功能的VINS-Mono，最终的漂移是[-0.032, 0.09, -0.07]米，对于整条轨迹长度而言，是微不足道的。</p><p>虽然我们不知道真值，但我们仍然可以从视觉上判断出优化后的轨迹是平滑的，并且可以精确地与卫星地图对齐。</p><h4 id="绕校园环境测试">绕校园环境测试</h4><p>这个庞大的数据集是用手持型VI-Sensor来记录的，它覆盖了整个科大校园，数据集覆盖的地面长约710m，宽约240m，高约60m，路径总长度是5.62km。数据包含了25Hz的图像和200Hz的IMU数据，持续了1个小时34分钟，这对于测试VINS-Mono的稳定性和耐久性是一项非常有意义。</p><p>在这个大规模的测试中，为了提供足够的循环信息和实现实时性能，我们设置关键帧数据库的大小2000帧，然后使用Intel i7-4790在3.6GHz的频率下工作，测试如表格1所示。</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-20-23-10-11.png"></p><h4 id="应用1无人机的反馈控制">应用1：无人机的反馈控制</h4><p>我们使用VINS-Mono作为无人机的自动反馈控制，如图21所示，我们使用前视全局快门相机(MatrixVision mvBlueFOX-MLC200w)具有752x480的分辨率，并配备了190度鱼眼镜头。然后使用了<code>DJI A3</code>飞行控制器，用于获取IMU测量以及稳定机体姿态。</p><p>板载的计算资源是Intel i7-5500U 的CPU，频率为3.00GHz，对于广角相机而言，传统的pinhole相机模型不适用，这里采用了MEI模型[文献42]，然后使用了[文献43]介绍的工具来标定。</p><p>在本实验中，我们使用VINS-Mono的状态估计来测试自动轨迹跟踪的性能，在本实验中，关闭回环功能，命令四旋翼飞行器跟踪一个”8”字图形，每个圆的半径为1.0米，如图21所示</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-20-23-20-04.png"></p><p>在预定义轨迹周围设置四个障碍物，以验证无闭环情况下VINS-Mono的精度。</p><p>真值使用<code>OptiTrack</code>来获得，整条轨迹长度61.97米，最终漂移为[0.08,0.09,0.13]米，位置漂移为0.29%，具体的误差如图23所示</p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-20-23-26-32.png"></p><p><img src="/2020/04/13/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-04-20-23-26-44.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator&quot;&gt;1. VINS-Mono: A Robust and Versatile Monocular Visual-In
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>矩阵相关</title>
    <link href="http://yoursite.com/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/</id>
    <published>2020-04-07T09:48:25.000Z</published>
    <updated>2020-04-07T12:48:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加法">1. 加法</h1><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-49-04.png"></p><h2 id="加法性质">1.1. 加法性质</h2><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-49-18.png"></p><h1 id="数乘">2. 数乘</h1><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-49-42.png"></p><h2 id="数乘性质">2.1. 数乘性质</h2><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-50-06.png"></p><h1 id="转置">3. 转置</h1><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-50-17.png"></p><h2 id="共轭转置">3.1. 共轭转置</h2><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-50-42.png"></p><h2 id="转置性质">3.2. 转置性质</h2><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-51-00.png"></p><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-20-41-16.png"></p><h1 id="对称">4. 对称</h1><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-51-18.png"></p><h1 id="矩阵乘法">5. 矩阵乘法</h1><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-52-31.png"></p><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-53-28.png"></p><h2 id="矩阵乘法中的某一行或某一列的计算important">5.1. 矩阵乘法中的某一行或某一列的计算[Important]</h2><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-54-38.png"></p><p><strong>举例:</strong></p><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-57-25.png"></p><p><span class="math display">\[\begin{aligned}    [AB]_{2*}    &amp;=A_{2*}B \\    &amp;=    \begin{bmatrix}    \begin{bmatrix}        a_{21}*b_{11}+ \\        a_{22}*b_{21}+ \\        a_{23}*b_{31}    \end{bmatrix} &amp;    \begin{bmatrix}        a_{21}*b_{12}+ \\        a_{22}*b_{22}+ \\        a_{23}*b_{32}    \end{bmatrix} &amp;    \begin{bmatrix}        a_{21}*b_{13}+ \\        a_{22}*b_{23}+ \\        a_{23}*b_{33}    \end{bmatrix}    \end{bmatrix} \\    &amp;=    \begin{bmatrix}        a_{21}*[b_{11},b_{12},b_{13}]+ \\        a_{22}*[b_{21},b_{22},b_{23}]+ \\        a_{23}*[b_{31},b_{32},b_{33}]    \end{bmatrix} \\    &amp;=    \begin{bmatrix}        a_{21}B_{1*}+ \\        a_{22}B_{2*}+ \\        a_{23}B_{3*}    \end{bmatrix}_{1\times 3}\end{aligned}\]</span></p><h2 id="矩阵块乘法">5.2. 矩阵块乘法</h2><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-20-41-49.png"></p><h2 id="乘法分配">5.3. 乘法分配</h2><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-20-40-38.png"></p><h1 id="矩阵的逆">6. 矩阵的逆</h1><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-20-42-32.png"></p><h2 id="矩阵等式">6.1. 矩阵等式</h2><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-20-43-07.png"></p><h2 id="如果矩阵的逆存在">6.2. 如果矩阵的逆存在</h2><p>则下面几条描述是等价的:</p><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-20-43-59.png"></p><h2 id="计算矩阵的逆">6.3. 计算矩阵的逆</h2><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-20-44-46.png"></p><h2 id="逆的性质">6.4. 逆的性质</h2><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-20-45-39.png"></p><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-20-45-57.png"></p><h1 id="线性函数">7. 线性函数</h1><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-51-48.png"></p><h2 id="线性组合">7.1. 线性组合</h2><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-52-06.png"></p><h2 id="线性系统">7.2. 线性系统</h2><p><img src="/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-18-07-43.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;加法&quot;&gt;1. 加法&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/04/07/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/2020-04-07-17-49-04.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;加法性质&quot;&gt;1.1. 加法性质&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Gauges-and-Gauge-Transformations</title>
    <link href="http://yoursite.com/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/"/>
    <id>http://yoursite.com/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/</id>
    <published>2020-04-07T02:26:01.000Z</published>
    <updated>2020-04-07T07:53:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gauges-and-gauge-transformations-for-uncertainty-description-of-geometric-structure-with-indeterminacy">1. Gauges and Gauge Transformations for Uncertainty Description of Geometric Structure with Indeterminacy</h1><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-10-27-01.png"></p><h1 id="摘要">2. 摘要</h1><p>本文提出了一种一致的理论，用于描述从一系列图像中进行三维重建过程中的确定性和不确定性</p><p>首先给出关于<code>gauges</code>和<code>gauge transformations</code>的相关理论，然后讨论了如何评价具有不确定性的解的可靠性，并将克拉美罗下界推广到包含内部不确定性。</p><p>另外还介绍了<code>free-gauge approach</code>，然后定义了独立于特定规格的协方差矩阵的标准形式</p><h1 id="介绍">3. 介绍</h1><p>从图像中进行3D重建包含了不确定性。</p><p>这些不确定性可以通过施加一些<code>normalization</code>的约束来移除，例如:</p><ul><li>我们可以将坐标原点固定在对象的特定点上，并将对象的大小标准化为单位长度</li><li>而固定参数则定义为没有不确定性，其他所有参数的不确定性均被改变</li></ul><h1 id="d重建问题">4. 3D重建问题</h1><p>在本文中，我们将重点放在基于特征的方法上: 我们追踪图像序列上的可识别特征点(如角点和标记点)的运动，并利用摄像机投影模型的知识计算它们的三维位置</p><p>假设我们在M幅图像上跟踪N个刚性移动的特征点，令<span class="math inline">\((x_{ka},y_{ka})\)</span>为第k帧的第a个点的像素坐标</p><p>这里，我们采用以相机为中心的描述，假设一个物体在场景中相对于静止的相机移动，但是，如果我们将摄像机看作是移动的，并拍摄静止场景的图像，那么后续的分析基本上是相同的。</p><h2 id="目标函数">4.1. 目标函数</h2><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-11-41-50.png"></p><h1 id="gauges">5. Gauges</h1><p><code>gauge freedom</code>的存在表明了在参数空间<span class="math inline">\(\mathcal{M}\)</span>中，存在一个光滑流形，对于任意的点<span class="math inline">\(\theta\)</span>其给出的解都能使目标函数的值一样。</p><p>对于在上述的光滑流形中的两点，<span class="math inline">\(\theta\)</span>和<span class="math inline">\(\theta&#39;\)</span>是几何等价的，记为<span class="math inline">\(\theta \sim \theta&#39;\)</span>，其中<span class="math inline">\(\theta&#39;=g \theta\)</span>，<strong><span class="math inline">\(g()\)</span>代表的是该流形空间(零空间)中的两点的变换关系</strong></p><p>这意味着，对于这个等价关系，真正的参数空间不是<span class="math inline">\(\mathcal{M}\)</span>，而是<span class="math inline">\(\mathcal{M}\)</span>的商空间<span class="math inline">\(\mathcal{M}/\mathcal{G}\)</span>，记为<span class="math inline">\(\mathcal{M}_\theta\)</span></p><p>例如：<span class="math inline">\(\mathcal{M}\)</span>的子集包含了所有关于<span class="math inline">\(\theta\)</span>的等价</p><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-11-22-44.png"></p><p>如果<code>gauge</code>的自由度为r，那么<span class="math inline">\(\mathcal{M}_\theta\)</span>则是参数空间<span class="math inline">\(\mathcal{M}\)</span>的r维<code>submanifold</code>，并且称为是与参数<span class="math inline">\(\theta\)</span>相关的叶子</p><p>为了消除解的模糊性，我们定义其他流形空间，它与上面的流形相交于一点。</p><p>选取特定的<span class="math inline">\(\theta\)</span>值的一个自然的想法是，对于上面的<span class="math inline">\(\mathcal{M}_\theta\)</span>分配r个等式:</p><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-11-26-21.png"></p><p>每一个等式去除<code>gauge freedom</code>中的一个自由度，我们称这些等式为<code>gauge condition</code>，如果这些等式满足:</p><ul><li>它们在代数上是独立的，共同定义了一个在参数空间<span class="math inline">\(\mathcal{M}\)</span>中的<code>submanifold</code> <span class="math inline">\(\mathcal{C}\)</span>，称为<code>gauge manifold</code></li><li><code>gauge manifold</code> <span class="math inline">\(\mathcal{C}\)</span>与参数空间<span class="math inline">\(\mathcal{M}\)</span>中的所有叶子，即与<span class="math inline">\(\mathcal{M}_\theta\)</span>相交于一点</li><li>对于任何<span class="math inline">\(\theta \in \mathcal{M}_\theta\)</span>和<span class="math inline">\(\theta_C=C \cap \mathcal{M}_\theta\)</span>，存在一个独特(仅有一个)的变换g()，使得<span class="math inline">\(\theta_C=g\theta\)</span></li></ul><p>此后，<code>gauge</code>和<code>gauge manifold</code>都是一个意思，记为<span class="math inline">\(\mathcal{C}\)</span></p><p>通过引入<span class="math inline">\(\mathcal{C}\)</span>，我们可以找到一个与叶子<span class="math inline">\(\mathcal{M}_\theta\)</span>的独一无二的交点，并且同时满足目标函数最小值</p><h2 id="gauge-fix-approach">5.1. <code>gauge fix approach</code></h2><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-11-43-46.png"></p><p>其中，</p><ul><li><span class="math inline">\(t_k\)</span>是平移</li><li><span class="math inline">\(s_a\)</span>是尺度</li></ul><h1 id="估计的等价性定理">6. 估计的等价性定理</h1><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-12-22-59.png"></p><ul><li><span class="math inline">\(T_{\theta C}(\mathcal{M})\)</span>是参数空间<span class="math inline">\(\mathcal{M}\)</span>在参数<span class="math inline">\(\theta_C\)</span>处的正切空间(<code>tangent space</code>)，是一个n维的线性空间</li><li><span class="math inline">\(T_{\theta C}(\mathcal{C})\)</span>是<code>gauge manifold</code> <span class="math inline">\(\mathcal{C}\)</span>在参数<span class="math inline">\(\theta_C\)</span>处的正切空间，它是<span class="math inline">\(T_{\theta C}(\mathcal{M})\)</span>的(n-r)维子空间</li><li>n: 参数向量<span class="math inline">\(\theta\)</span>的维度数</li><li>r: <code>gauge freedom</code>的自由度</li><li>n-r: 可观测的维度</li></ul><h2 id="图1的个人理解">6.1. 图1的个人理解</h2><ul><li>已知在<span class="math inline">\(M_\theta\)</span>轨道上，任意一点都可以满足使得目标函数<span class="math inline">\(J()\)</span>最小化</li><li>假定轨道上某一点<span class="math inline">\(\theta_C\)</span>处，求得了一个增量<span class="math inline">\(\phi_\theta\)</span>，显然，这个增量有一部分分量不会改变目标函数<span class="math inline">\(J()\)</span>的能量</li><li>在点<span class="math inline">\(\theta_C\)</span>处，存在一个正切流形空间<span class="math inline">\(T_{\theta_C}(M_\theta)\)</span>，增量<span class="math inline">\(\phi_\theta\)</span>在这个正切空间上的投影量，只会使得<span class="math inline">\(\theta_C\)</span>点沿着<span class="math inline">\(M_\theta\)</span>轨道移动，而不是沿着垂直方向移动，因此，这部分分量并不改变目标函数<span class="math inline">\(J()\)</span>的能量</li><li>那么这个在点<span class="math inline">\(\theta_C\)</span>处的正切流形空间<span class="math inline">\(T_{\theta_C}(M_\theta)\)</span>，也就是所说的零空间</li></ul><h2 id="关于零空间的基">6.2. 关于零空间的基</h2><p>零空间的基，实际上就是正切流形空间<span class="math inline">\(T_{\theta_C}(M_\theta)\)</span>的基，可以通过在<span class="math inline">\(M_\theta\)</span>轨道在<span class="math inline">\(\theta_C\)</span>处使用小量来进行计算，这跟计算切向量的方法一样的</p><p>举例: 求<span class="math inline">\(\theta_C\)</span>处，关于位姿的平移量x值的零空间基</p><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-15-47-25.png"></p><hr><h2 id="等价性的推导">6.3. 等价性的推导</h2><p>在这一节中，我们定义了在<code>gauge manifold</code>上的斜投影，并证明所有投影到相同点上的扰动在几何上是等价的</p><p>设<span class="math inline">\(\hat{\theta}_C\)</span>是参数<span class="math inline">\(\theta\)</span>对于<code>gauge</code> <span class="math inline">\(\mathcal{C}\)</span>的估计。 使用一阶近似，那么作差<span class="math inline">\(\Delta \theta_C=\hat{\theta}_C-\theta_C\)</span>可以使用<span class="math inline">\(T_{\theta C}(\mathcal{C})\)</span>中的一个元素来标识</p><ul><li>注意: <span class="math inline">\(\hat{\theta}_C\)</span>和<span class="math inline">\(\theta_C\)</span>都表示状态</li><li><span class="math inline">\(\Delta \theta_C\)</span>才表示增量</li></ul><p>令<span class="math inline">\(\Delta \theta \in T_{\theta C}(\mathcal{M})\)</span>是一个任意的向量(也就是下图中的向量1)，则有:</p><ul><li><p>当且仅当<span class="math inline">\(\Delta \theta-\Delta \theta_C \in T_{\theta C}(\mathcal{M}_\theta)\)</span> ，(也就是下图的向量1-向量2，得到向量的<span class="math inline">\(Q_{\theta_C}^C\)</span>)，那么有:</p><p><span class="math inline">\(\theta_C+\Delta \theta\)</span>与<span class="math inline">\(\hat{\theta}_C=\theta_C+\Delta \theta_C\)</span>是几何等价的</p></li></ul><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-12-56-19.png"></p><p>因为<span class="math inline">\(\{D_1(\theta_C),\cdots,D_r(\theta_C)\}\)</span>是空间<span class="math inline">\(T_{\theta C}(\mathcal{M}_\theta)\)</span>的基 （零空间的基），那么上面的条件等价于: 存在r个数字<span class="math inline">\((x_1,\cdots,x_r)\)</span>，使得:</p><p><span class="math display">\[    \Delta \theta_C=\Delta \theta + \sum_{i=1}^r x_i D_i(\theta_C)\]</span></p><p>或者说</p><p><span class="math display">\[    \Delta \theta_C=\Delta \theta + U_{\theta_C} x \tag{36}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(x=(x_1,\cdots,x_r)^T\)</span></li><li><span class="math inline">\(U_{\theta_C}=(D_1(\theta_C),\cdots,D_r(\theta_C))\)</span></li></ul><p>如果<code>gauge</code> <span class="math inline">\(\mathcal{C}\)</span> 由r个等式来定义，即:</p><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-11-26-21.png"></p><p>那么，正切空间<span class="math inline">\(T_{\theta C}(\mathcal{C})\)</span>是</p><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-13-11-54.png"></p><p>张成的线性空间的正交互补空间</p><p>根据<span class="math inline">\(\triangledown_{\theta C_i}|\theta_C\)</span>和<span class="math inline">\(\Delta \theta_C\)</span>之间作点乘等于0，对式36两边同时点乘<span class="math inline">\(V_{\theta_C}\)</span>，可以得到:</p><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-13-15-22.png"></p><p>其中,</p><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-13-16-11.png"></p><p>对(式36)和(式38)，消去<span class="math inline">\(x\)</span>，可以得到:</p><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-13-19-45.png"></p><p>这，就是定义了一个沿着<span class="math inline">\(T_{\theta C}(\mathcal{M}_\theta)\)</span>到<span class="math inline">\(T_{\theta C}(\mathcal{C})\)</span>的(斜)投影</p><p><strong>因此，得到如下定理</strong>:</p><p>一个估计<span class="math inline">\(\hat{\theta}_C\)</span>与<span class="math inline">\(\theta_C+\Delta \theta\)</span>是几何等价的，当且仅当:</p><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-13-25-06.png"></p><h1 id="数值优化">7. 数值优化</h1><p>问题是给定<code>gauge</code>，如何用数值方法求得最优估计量</p><p>牛顿迭代法具有良好的二次收敛性，但同时，解需要满足<code>gauge condiction</code></p><p>目标函数<span class="math inline">\(J\)</span>通过在<code>gauge</code> <span class="math inline">\(\mathcal{C}\)</span>下的真值<span class="math inline">\(\bar{\theta}_C\)</span>附近展开，有:</p><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-13-32-41.png"></p><p>其中，上面的括号<span class="math inline">\((m,n)\)</span>表示点乘运算</p><ul><li><p><span class="math inline">\(\triangledown_{\theta}J，\triangledown_{\theta}^2J\)</span>分别表示目标函数<span class="math inline">\(J\)</span>对参数<span class="math inline">\(\theta\)</span>的一阶偏导和二阶偏导</p></li><li><p>表达式中符号上面的横杠，如<span class="math inline">\(\bar{J},\triangledown_\theta \bar{J}, \triangledown_\theta^2 \bar{J}\)</span>表示的是在真值<span class="math inline">\(\bar{\theta}_C\)</span>处进行计算得到的值（也就是线性化点得到值）</p></li><li><p><span class="math inline">\(\Delta \theta\)</span>是使用真值<span class="math inline">\(\bar{\theta}_C\)</span>处的正切空间<span class="math inline">\(T_{\bar{\theta}_C(\mathcal{M})}\)</span>的元素来标识的</p><p>即<span class="math inline">\(\Delta \theta\)</span>是在<span class="math inline">\(T_{\bar{\theta}_C(\mathcal{M})}\)</span>的局部坐标系下的，如 局部扰动向量<span class="math inline">\(\Delta R_{3\times1}\)</span> (回想四元数的更新，局部扰动)</p><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-13-42-50.png"></p></li></ul><p>忽略掉目标函数(式68)中的其他高阶项如<span class="math inline">\(O(\epsilon^3)\)</span>，减去在<span class="math inline">\(\bar{\theta}_C\)</span>处的真值<span class="math inline">\(\bar{J}\)</span>，然后令等式为0，可以得到:</p><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-13-47-52.png"></p><p>因为Hessian矩阵，即<span class="math inline">\(\triangledown_{\theta}^2J\)</span>的秩是<span class="math inline">\(n-r\)</span>，这个等式有无穷多个解。</p><p>上述(式69)，相当于高斯牛顿中的:</p><p><span class="math display">\[\begin{aligned}    H\Delta x=b \\    J^T J \Delta x = -J^T r\end{aligned}\]</span></p><p>这里有两种选择，</p><ol type="1"><li>一是通过使用<span class="math inline">\(r\)</span>条等式与(式69)进行结合（这相当于在目标函数中添加约束项(惩罚项)，作为先验）:</li></ol><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-13-52-00.png"></p><p>来约束<span class="math inline">\(\Delta \theta\)</span>在正切空间<span class="math inline">\(T_{\theta}(\mathcal{C})\)</span>，（这是相当于添加先验的方法），由此产生的线性方程组可以确定唯一的解<span class="math inline">\(\Delta \theta\)</span></p><ol start="2" type="1"><li>另外一种方法是，首先直接计算(式69)的任意一个解</li></ol><p>求解的过程中，需要用到伪逆(Moore-Penrose)</p><p>然后，根据定理，我们需要利用<code>gauge</code> <span class="math inline">\(\mathcal{C}\)</span>，即用<span class="math inline">\(Q_{\theta}^C \Delta \theta\)</span>来代替<span class="math inline">\(\Delta \theta\)</span>，最终可以得到:</p><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-14-05-20.png"></p><p>(这个的意思是，先求出一个任意解，然后再减去这个解在零空间上的分量)</p><p><code>Free-Gauge Approach</code>过程可以使用图来描述</p><p><img src="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/2020-04-07-14-17-44.png"></p><p>值得注意的是:</p><ul><li><code>Free-Gauge Approach</code>是沿着与<span class="math inline">\(\mathcal{M}_\theta\)</span>正交的方向去迭代的，因此，其收敛速度会更快一些。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gauges-and-gauge-transformations-for-uncertainty-description-of-geometric-structure-with-indeterminacy&quot;&gt;1. Gauges and Gauge Transfor
      
    
    </summary>
    
    
      <category term="SLAM代码课程" scheme="http://yoursite.com/categories/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Gauges-and-Gauge-Transformations</title>
    <link href="http://yoursite.com/2020/04/07/Gauges-and-Gauge-Transformations/"/>
    <id>http://yoursite.com/2020/04/07/Gauges-and-Gauge-Transformations/</id>
    <published>2020-04-07T02:26:01.000Z</published>
    <updated>2020-04-07T07:53:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gauges-and-gauge-transformations-for-uncertainty-description-of-geometric-structure-with-indeterminacy">1. Gauges and Gauge Transformations for Uncertainty Description of Geometric Structure with Indeterminacy</h1><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-10-27-01.png"></p><h1 id="摘要">2. 摘要</h1><p>本文提出了一种一致的理论，用于描述从一系列图像中进行三维重建过程中的确定性和不确定性</p><p>首先给出关于<code>gauges</code>和<code>gauge transformations</code>的相关理论，然后讨论了如何评价具有不确定性的解的可靠性，并将克拉美罗下界推广到包含内部不确定性。</p><p>另外还介绍了<code>free-gauge approach</code>，然后定义了独立于特定规格的协方差矩阵的标准形式</p><h1 id="介绍">3. 介绍</h1><p>从图像中进行3D重建包含了不确定性。</p><p>这些不确定性可以通过施加一些<code>normalization</code>的约束来移除，例如:</p><ul><li>我们可以将坐标原点固定在对象的特定点上，并将对象的大小标准化为单位长度</li><li>而固定参数则定义为没有不确定性，其他所有参数的不确定性均被改变</li></ul><h1 id="d重建问题">4. 3D重建问题</h1><p>在本文中，我们将重点放在基于特征的方法上: 我们追踪图像序列上的可识别特征点(如角点和标记点)的运动，并利用摄像机投影模型的知识计算它们的三维位置</p><p>假设我们在M幅图像上跟踪N个刚性移动的特征点，令<span class="math inline">\((x_{ka},y_{ka})\)</span>为第k帧的第a个点的像素坐标</p><p>这里，我们采用以相机为中心的描述，假设一个物体在场景中相对于静止的相机移动，但是，如果我们将摄像机看作是移动的，并拍摄静止场景的图像，那么后续的分析基本上是相同的。</p><h2 id="目标函数">4.1. 目标函数</h2><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-11-41-50.png"></p><h1 id="gauges">5. Gauges</h1><p><code>gauge freedom</code>的存在表明了在参数空间<span class="math inline">\(\mathcal{M}\)</span>中，存在一个光滑流形，对于任意的点<span class="math inline">\(\theta\)</span>其给出的解都能使目标函数的值一样。</p><p>对于在上述的光滑流形中的两点，<span class="math inline">\(\theta\)</span>和<span class="math inline">\(\theta&#39;\)</span>是几何等价的，记为<span class="math inline">\(\theta \sim \theta&#39;\)</span>，其中<span class="math inline">\(\theta&#39;=g \theta\)</span>，<strong><span class="math inline">\(g()\)</span>代表的是该流形空间(零空间)中的两点的变换关系</strong></p><p>这意味着，对于这个等价关系，真正的参数空间不是<span class="math inline">\(\mathcal{M}\)</span>，而是<span class="math inline">\(\mathcal{M}\)</span>的商空间<span class="math inline">\(\mathcal{M}/\mathcal{G}\)</span>，记为<span class="math inline">\(\mathcal{M}_\theta\)</span></p><p>例如：<span class="math inline">\(\mathcal{M}\)</span>的子集包含了所有关于<span class="math inline">\(\theta\)</span>的等价</p><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-11-22-44.png"></p><p>如果<code>gauge</code>的自由度为r，那么<span class="math inline">\(\mathcal{M}_\theta\)</span>则是参数空间<span class="math inline">\(\mathcal{M}\)</span>的r维<code>submanifold</code>，并且称为是与参数<span class="math inline">\(\theta\)</span>相关的叶子</p><p>为了消除解的模糊性，我们定义其他流形空间，它与上面的流形相交于一点。</p><p>选取特定的<span class="math inline">\(\theta\)</span>值的一个自然的想法是，对于上面的<span class="math inline">\(\mathcal{M}_\theta\)</span>分配r个等式:</p><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-11-26-21.png"></p><p>每一个等式去除<code>gauge freedom</code>中的一个自由度，我们称这些等式为<code>gauge condition</code>，如果这些等式满足:</p><ul><li>它们在代数上是独立的，共同定义了一个在参数空间<span class="math inline">\(\mathcal{M}\)</span>中的<code>submanifold</code> <span class="math inline">\(\mathcal{C}\)</span>，称为<code>gauge manifold</code></li><li><code>gauge manifold</code> <span class="math inline">\(\mathcal{C}\)</span>与参数空间<span class="math inline">\(\mathcal{M}\)</span>中的所有叶子，即与<span class="math inline">\(\mathcal{M}_\theta\)</span>相交于一点</li><li>对于任何<span class="math inline">\(\theta \in \mathcal{M}_\theta\)</span>和<span class="math inline">\(\theta_C=C \cap \mathcal{M}_\theta\)</span>，存在一个独特(仅有一个)的变换g()，使得<span class="math inline">\(\theta_C=g\theta\)</span></li></ul><p>此后，<code>gauge</code>和<code>gauge manifold</code>都是一个意思，记为<span class="math inline">\(\mathcal{C}\)</span></p><p>通过引入<span class="math inline">\(\mathcal{C}\)</span>，我们可以找到一个与叶子<span class="math inline">\(\mathcal{M}_\theta\)</span>的独一无二的交点，并且同时满足目标函数最小值</p><h2 id="gauge-fix-approach">5.1. <code>gauge fix approach</code></h2><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-11-43-46.png"></p><p>其中，</p><ul><li><span class="math inline">\(t_k\)</span>是平移</li><li><span class="math inline">\(s_a\)</span>是尺度</li></ul><h1 id="估计的等价性定理">6. 估计的等价性定理</h1><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-12-22-59.png"></p><ul><li><span class="math inline">\(T_{\theta C}(\mathcal{M})\)</span>是参数空间<span class="math inline">\(\mathcal{M}\)</span>在参数<span class="math inline">\(\theta_C\)</span>处的正切空间(<code>tangent space</code>)，是一个n维的线性空间</li><li><span class="math inline">\(T_{\theta C}(\mathcal{C})\)</span>是<code>gauge manifold</code> <span class="math inline">\(\mathcal{C}\)</span>在参数<span class="math inline">\(\theta_C\)</span>处的正切空间，它是<span class="math inline">\(T_{\theta C}(\mathcal{M})\)</span>的(n-r)维子空间</li><li>n: 参数向量<span class="math inline">\(\theta\)</span>的维度数</li><li>r: <code>gauge freedom</code>的自由度</li><li>n-r: 可观测的维度</li></ul><h2 id="图1的个人理解">6.1. 图1的个人理解</h2><ul><li>已知在<span class="math inline">\(M_\theta\)</span>轨道上，任意一点都可以满足使得目标函数<span class="math inline">\(J()\)</span>最小化</li><li>假定轨道上某一点<span class="math inline">\(\theta_C\)</span>处，求得了一个增量<span class="math inline">\(\phi_\theta\)</span>，显然，这个增量有一部分分量不会改变目标函数<span class="math inline">\(J()\)</span>的能量</li><li>在点<span class="math inline">\(\theta_C\)</span>处，存在一个正切流形空间<span class="math inline">\(T_{\theta_C}(M_\theta)\)</span>，增量<span class="math inline">\(\phi_\theta\)</span>在这个正切空间上的投影量，只会使得<span class="math inline">\(\theta_C\)</span>点沿着<span class="math inline">\(M_\theta\)</span>轨道移动，而不是沿着垂直方向移动，因此，这部分分量并不改变目标函数<span class="math inline">\(J()\)</span>的能量</li><li>那么这个在点<span class="math inline">\(\theta_C\)</span>处的正切流形空间<span class="math inline">\(T_{\theta_C}(M_\theta)\)</span>，也就是所说的零空间</li></ul><h2 id="关于零空间的基">6.2. 关于零空间的基</h2><p>零空间的基，实际上就是正切流形空间<span class="math inline">\(T_{\theta_C}(M_\theta)\)</span>的基，可以通过在<span class="math inline">\(M_\theta\)</span>轨道在<span class="math inline">\(\theta_C\)</span>处使用小量来进行计算，这跟计算切向量的方法一样的</p><p>举例: 求<span class="math inline">\(\theta_C\)</span>处，关于位姿的平移量x值的零空间基</p><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-15-47-25.png"></p><hr><h2 id="等价性的推导">6.3. 等价性的推导</h2><p>在这一节中，我们定义了在<code>gauge manifold</code>上的斜投影，并证明所有投影到相同点上的扰动在几何上是等价的</p><p>设<span class="math inline">\(\hat{\theta}_C\)</span>是参数<span class="math inline">\(\theta\)</span>对于<code>gauge</code> <span class="math inline">\(\mathcal{C}\)</span>的估计。 使用一阶近似，那么作差<span class="math inline">\(\Delta \theta_C=\hat{\theta}_C-\theta_C\)</span>可以使用<span class="math inline">\(T_{\theta C}(\mathcal{C})\)</span>中的一个元素来标识</p><ul><li>注意: <span class="math inline">\(\hat{\theta}_C\)</span>和<span class="math inline">\(\theta_C\)</span>都表示状态</li><li><span class="math inline">\(\Delta \theta_C\)</span>才表示增量</li></ul><p>令<span class="math inline">\(\Delta \theta \in T_{\theta C}(\mathcal{M})\)</span>是一个任意的向量(也就是下图中的向量1)，则有:</p><ul><li><p>当且仅当<span class="math inline">\(\Delta \theta-\Delta \theta_C \in T_{\theta C}(\mathcal{M}_\theta)\)</span> ，(也就是下图的向量1-向量2，得到向量的<span class="math inline">\(Q_{\theta_C}^C\)</span>)，那么有:</p><p><span class="math inline">\(\theta_C+\Delta \theta\)</span>与<span class="math inline">\(\hat{\theta}_C=\theta_C+\Delta \theta_C\)</span>是几何等价的</p></li></ul><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-12-56-19.png"></p><p>因为<span class="math inline">\(\{D_1(\theta_C),\cdots,D_r(\theta_C)\}\)</span>是空间<span class="math inline">\(T_{\theta C}(\mathcal{M}_\theta)\)</span>的基 （零空间的基），那么上面的条件等价于: 存在r个数字<span class="math inline">\((x_1,\cdots,x_r)\)</span>，使得:</p><p><span class="math display">\[    \Delta \theta_C=\Delta \theta + \sum_{i=1}^r x_i D_i(\theta_C)\]</span></p><p>或者说</p><p><span class="math display">\[    \Delta \theta_C=\Delta \theta + U_{\theta_C} x \tag{36}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(x=(x_1,\cdots,x_r)^T\)</span></li><li><span class="math inline">\(U_{\theta_C}=(D_1(\theta_C),\cdots,D_r(\theta_C))\)</span></li></ul><p>如果<code>gauge</code> <span class="math inline">\(\mathcal{C}\)</span> 由r个等式来定义，即:</p><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-11-26-21.png"></p><p>那么，正切空间<span class="math inline">\(T_{\theta C}(\mathcal{C})\)</span>是</p><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-13-11-54.png"></p><p>张成的线性空间的正交互补空间</p><p>根据<span class="math inline">\(\triangledown_{\theta C_i}|\theta_C\)</span>和<span class="math inline">\(\Delta \theta_C\)</span>之间作点乘等于0，对式36两边同时点乘<span class="math inline">\(V_{\theta_C}\)</span>，可以得到:</p><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-13-15-22.png"></p><p>其中,</p><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-13-16-11.png"></p><p>对(式36)和(式38)，消去<span class="math inline">\(x\)</span>，可以得到:</p><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-13-19-45.png"></p><p>这，就是定义了一个沿着<span class="math inline">\(T_{\theta C}(\mathcal{M}_\theta)\)</span>到<span class="math inline">\(T_{\theta C}(\mathcal{C})\)</span>的(斜)投影</p><p><strong>因此，得到如下定理</strong>:</p><p>一个估计<span class="math inline">\(\hat{\theta}_C\)</span>与<span class="math inline">\(\theta_C+\Delta \theta\)</span>是几何等价的，当且仅当:</p><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-13-25-06.png"></p><h1 id="数值优化">7. 数值优化</h1><p>问题是给定<code>gauge</code>，如何用数值方法求得最优估计量</p><p>牛顿迭代法具有良好的二次收敛性，但同时，解需要满足<code>gauge condiction</code></p><p>目标函数<span class="math inline">\(J\)</span>通过在<code>gauge</code> <span class="math inline">\(\mathcal{C}\)</span>下的真值<span class="math inline">\(\bar{\theta}_C\)</span>附近展开，有:</p><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-13-32-41.png"></p><p>其中，上面的括号<span class="math inline">\((m,n)\)</span>表示点乘运算</p><ul><li><p><span class="math inline">\(\triangledown_{\theta}J，\triangledown_{\theta}^2J\)</span>分别表示目标函数<span class="math inline">\(J\)</span>对参数<span class="math inline">\(\theta\)</span>的一阶偏导和二阶偏导</p></li><li><p>表达式中符号上面的横杠，如<span class="math inline">\(\bar{J},\triangledown_\theta \bar{J}, \triangledown_\theta^2 \bar{J}\)</span>表示的是在真值<span class="math inline">\(\bar{\theta}_C\)</span>处进行计算得到的值（也就是线性化点得到值）</p></li><li><p><span class="math inline">\(\Delta \theta\)</span>是使用真值<span class="math inline">\(\bar{\theta}_C\)</span>处的正切空间<span class="math inline">\(T_{\bar{\theta}_C(\mathcal{M})}\)</span>的元素来标识的</p><p>即<span class="math inline">\(\Delta \theta\)</span>是在<span class="math inline">\(T_{\bar{\theta}_C(\mathcal{M})}\)</span>的局部坐标系下的，如 局部扰动向量<span class="math inline">\(\Delta R_{3\times1}\)</span> (回想四元数的更新，局部扰动)</p><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-13-42-50.png"></p></li></ul><p>忽略掉目标函数(式68)中的其他高阶项如<span class="math inline">\(O(\epsilon^3)\)</span>，减去在<span class="math inline">\(\bar{\theta}_C\)</span>处的真值<span class="math inline">\(\bar{J}\)</span>，然后令等式为0，可以得到:</p><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-13-47-52.png"></p><p>因为Hessian矩阵，即<span class="math inline">\(\triangledown_{\theta}^2J\)</span>的秩是<span class="math inline">\(n-r\)</span>，这个等式有无穷多个解。</p><p>上述(式69)，相当于高斯牛顿中的:</p><p><span class="math display">\[\begin{aligned}    H\Delta x=b \\    J^T J \Delta x = -J^T r\end{aligned}\]</span></p><p>这里有两种选择，</p><ol type="1"><li>一是通过使用<span class="math inline">\(r\)</span>条等式与(式69)进行结合（这相当于在目标函数中添加约束项(惩罚项)，作为先验）:</li></ol><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-13-52-00.png"></p><p>来约束<span class="math inline">\(\Delta \theta\)</span>在正切空间<span class="math inline">\(T_{\theta}(\mathcal{C})\)</span>，（这是相当于添加先验的方法），由此产生的线性方程组可以确定唯一的解<span class="math inline">\(\Delta \theta\)</span></p><ol start="2" type="1"><li>另外一种方法是，首先直接计算(式69)的任意一个解</li></ol><p>求解的过程中，需要用到伪逆(Moore-Penrose)</p><p>然后，根据定理，我们需要利用<code>gauge</code> <span class="math inline">\(\mathcal{C}\)</span>，即用<span class="math inline">\(Q_{\theta}^C \Delta \theta\)</span>来代替<span class="math inline">\(\Delta \theta\)</span>，最终可以得到:</p><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-14-05-20.png"></p><p>(这个的意思是，先求出一个任意解，然后再减去这个解在零空间上的分量)</p><p><code>Free-Gauge Approach</code>过程可以使用图来描述</p><p><img src="/2020/04/07/Gauges-and-Gauge-Transformations/2020-04-07-14-17-44.png"></p><p>值得注意的是:</p><ul><li><code>Free-Gauge Approach</code>是沿着与<span class="math inline">\(\mathcal{M}_\theta\)</span>正交的方向去迭代的，因此，其收敛速度会更快一些。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gauges-and-gauge-transformations-for-uncertainty-description-of-geometric-structure-with-indeterminacy&quot;&gt;1. Gauges and Gauge Transfor
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>VI中的几种自由度处理方法的性能对比</title>
    <link href="http://yoursite.com/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</id>
    <published>2020-04-06T02:01:39.000Z</published>
    <updated>2020-04-07T07:55:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="on-the-comparison-of-gauge-freedom-handling-in-optimization-based-visual-inertial-state-estimation">1. On the Comparison of Gauge Freedom Handling in Optimization-based Visual-Inertial State Estimation</h1><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-03-24.png"></p><h1 id="摘要">2. 摘要</h1><p>VI系统中有4个不可观测自由度，绕重力方向的旋转和平移(在本文中称为<span class="math inline">\(gauge~freedom\)</span>)，以及剩下一些可观的自由度，在求解过程中需要进行特殊的处理。 文章对比了以下3种处理方法:</p><ul><li>gauge fixation: 设置不可观测的状态为某个固定的值</li><li>gauge prior: 为某个状态设置先验</li><li>free gauge: 让状态在优化过程中自由演化，优化完成再进行处理</li></ul><h1 id="vi问题">3. VI问题</h1><p>视觉-惯性状态估计的问题包括对摄像机-惯性组合传感器(IMU)的运动和传感器在场景中运动时摄像机看到的三维地标位置的推断。</p><p>通过收集视觉测量方程(图像点)和惯性测量(加速度计和陀螺仪)，问题可写成非线性最小二乘，目标是最小化下面的方程:</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-19-44.png"></p><p>其中</p><ul><li><span class="math inline">\(||r||_\Sigma^2=r^T\Sigma^{-1}r\)</span>是残差向量<span class="math inline">\(r\)</span>的马氏距离</li><li><span class="math inline">\(\Sigma\)</span>是测量值的协方差矩阵，作为权重</li><li>这个cost func 可以作为 "full smoothing"或者"fixed-lag smooth"方法</li></ul><p>视觉项由图像观测点<span class="math inline">\(x_ij\)</span>的重投影误差组成，惯性项包括惯性测量值与IMU轨迹模型预测值(预积分)之间的误差。</p><p>问题求解的状态向量如下:</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-30-00.png"></p><p>包括摄像机运动参数(外参和线速度)和3D场景(地标)。</p><p>加速度计和陀螺仪的bias通常施加在IMU坐标系中，因此不受坐标系固定的影响，因此，我们排除bias，并假设IMU的测量已经纠正。</p><h2 id="解的歧义性和几何等价">3.1. 解的歧义性和几何等价</h2><p>对于VI系统状态估计问题，很重要的一点是，对参数<span class="math inline">\(\theta\)</span>(或者说状态)给定特殊的变换<span class="math inline">\(g(\theta)\)</span>，最终的目标函数(cost func)<span class="math inline">\(J(\theta)\)</span>不变，即:</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-36-12.png"></p><p>特别的，变换<span class="math inline">\(g()\)</span>可以用齐次矩阵的形式表达:</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-36-48.png"></p><p>这是一个4自由度的变换，其中:</p><ul><li><span class="math inline">\(t \in \R^3\)</span>是任意的平移</li><li>旋转<span class="math inline">\(R_z=\exp (\alpha e_z)\)</span>是绕重力方向轴<span class="math inline">\(e_z=(0,0,1)^T\)</span>的任意yaw角<span class="math inline">\(\alpha \in (-\pi,\pi)\)</span>所产生的旋转矩阵</li><li>为了简化表达，使用<span class="math inline">\(Exp(\theta)=\exp(\theta^\wedge)\)</span>来表示这个变换</li></ul><p>通过对状态应用上面的变换<span class="math inline">\(g(\theta)\)</span>，将得到新的状态<span class="math inline">\(\theta&#39; \equiv {p_i&#39;,R_i&#39;,v_i&#39;,X_j&#39;}\)</span></p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-42-52.png"></p><p><strong>对于<span class="math inline">\(\theta\)</span>和<span class="math inline">\(\theta&#39;\)</span>，它们是几何等价的，它们产生相同的误差，即，对于目标函数<span class="math inline">\(J(\theta)\)</span>，它们最终得到的值是一样的。</strong></p><p>作为不变性的结果，参数空间<span class="math inline">\(\mathcal{M}\)</span>可以分解成几何等价重构的不相交集合(即使用基来表示)，这些几何可以称为<span class="math inline">\(orbit\)</span>或者<span class="math inline">\(leaf\)</span></p><p>于是，关于<span class="math inline">\(\theta\)</span>的<span class="math inline">\(orbit\)</span>可以如下表示:</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-48-34.png"></p><p>其中,</p><ul><li><span class="math inline">\(\mathcal{G}\)</span>是<span class="math inline">\(g()\)</span>变换的群，注意到目标函数在每一个<span class="math inline">\(orbit\)</span>上都是常数(意思是存在变换<span class="math inline">\(g()\)</span>，都不会改变目标函数的值)</li></ul><p>不变性的主要结果是没有一个特定的解，原因是有无穷多个解可以使得目标函数达到同样的最小值，</p><p>如下图2: <span class="math inline">\(orbit\)</span>上的所有状态都可以达到同样的最小值(对于目标函数而言)</p><p>因此，VI状态估计问题具有不确定或者说不可观测的状态: 没有足够的方程来完全指定一个唯一解。</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-55-37.png"></p><p>上面是三种处理方法关于参数向量维度的对比:</p><ul><li>总的参数<span class="math inline">\(n=9N+3K\)</span>，N是相机节点数，K是路标数</li></ul><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-55-48.png"></p><h2 id="附加约束指定一个gauge">3.2. 附加约束:指定一个Gauge</h2><p>用附加约束完成(1)的处理</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-58-58.png"></p><p>这会产生一个独特的解，称为指定一个<span class="math inline">\(gauge\)</span>，C</p><p>换句话说，就是上面的(等式7)，选择了一个有代表性的<span class="math inline">\(orbit\)</span>，用来消除等价中的不确定性，在VI系统中，这是通过指定3D的参考坐标系来实现的。</p><p>举例: 选择包含第0帧的相机（固定其位姿为position={0,0,0},yaw=0）作为参考坐标系。这些约束指定了一个唯一的转换，因此，这个独特的解就是<span class="math inline">\(\mathcal{C}\)</span>和参数空间<span class="math inline">\(\mathcal{M}_\theta\)</span>的并集，即:</p><p><span class="math display">\[    \theta_C=\mathcal{C}\cap \mathcal{M}_\theta\]</span></p><p>那么<span class="math inline">\(gauge\)</span>，C，与轨道<span class="math inline">\(orbit\)</span>也就是<span class="math inline">\(\mathcal{M}_\theta\)</span>是横断的，因此，得到的解<span class="math inline">\(\theta_C\)</span>是唯一的</p><h1 id="处理gauge">4. 处理Gauge</h1><p>从优化的角度来看，使用高斯牛顿来对上面提到的目标函数进行求解会有一些困难，即使我们使用所有元素的最小参数化状态参数向量θ，目标函数中的海森矩阵(用于参数更新的<span class="math inline">\(H\Delta x\)</span>=b)，由于存在不可观测的自由度，因此是奇异的。</p><p>更加具体的说就是，它是一个秩亏矩阵，rank缺了4，恰恰对应了变换<span class="math inline">\(g()\)</span>中的4个自由度。</p><p>上面的Table 1 列出了3种常用的处理方法，其中，</p><ul><li>(gauge fixation approach)是<strong>在一个较小的参数空间中进行优化</strong>，在这个空间中没有不可观测的状态，因此Hessian是可逆的，这本质上强制了解的硬约束</li><li>(gauge prior approach)是<strong>通过附加惩罚</strong>(来产生一个可逆的Hessian)来增强目标函数，以使解决方案以一种软的方式满足某些约束</li><li>(free gauge approach)使用<strong>H的伪逆</strong>，来隐式地为唯一解决方案提供额外的约束(用最小范数更新参数)</li></ul><p>前两种策略需要特定于VI问题的知识(需要约束的状态)，而最后一种策略是通用的</p><h2 id="rotation-parametrization-for-gauge-fixation-or-prior">4.1. Rotation Parametrization for Gauge Fixation or Prior</h2><p>使用<code>gauge fixation</code>和<code>gauge prior</code>方法存在一个问题就是，固定相机位姿的1自由度yaw旋转角并不直接。</p><p>在使用求解器(如高斯牛顿、LM)迭代时，标准的更新旋转量的方法是:</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-11-38-19.png"></p><p>其中，q代表第q次迭代</p><p>通过设置<span class="math inline">\(\delta \phi^q\)</span>中关于<span class="math inline">\(z\)</span>的元素为0，就可以对<span class="math inline">\(R^q\)</span>中的yaw角进行固定，然而，如果连接几次这样的更新，如<span class="math inline">\(R^Q=\prod_{q=0}^{Q-1} Exp(\delta \phi ^q)R^0\)</span>，即相当于经过多次更新之后，并不能把<span class="math inline">\(R^Q\)</span>的yaw角固定成与<span class="math inline">\(R^0\)</span>的一致，测试代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eigen3/Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eigen3/Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sophus/so3.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Eigen::Matrix3d  R= Eigen::Matrix3d::Identity();</span><br><span class="line">    <span class="function">Sophus::SO3d <span class="title">R_n</span><span class="params">(R)</span></span>;</span><br><span class="line">    R_n= Sophus::SO3d::<span class="built_in">exp</span>(Eigen::Vector3d(<span class="number">0.3</span>,<span class="number">0.1</span>,<span class="number">0</span>))*R_n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"First :"</span>&lt;&lt;R_n.<span class="built_in">log</span>().transpose()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    R_n= Sophus::SO3d::<span class="built_in">exp</span>(Eigen::Vector3d(<span class="number">0.1</span>,<span class="number">0.2</span>,<span class="number">0</span>))*R_n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Second :"</span>&lt;&lt;R_n.<span class="built_in">log</span>().transpose()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    R_n= Sophus::SO3d::<span class="built_in">exp</span>(Eigen::Vector3d(<span class="number">0.5</span>,<span class="number">0.1</span>,<span class="number">0</span>))*R_n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Third :"</span>&lt;&lt;R_n.<span class="built_in">log</span>().transpose()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">First :   0.3 0.1   0</span><br><span class="line">Second :  0.399579    0.29916 -0.0251046</span><br><span class="line">Third : 0.896385  0.404603 0.0308449</span><br></pre></td></tr></table></figure><p>尽管使用yaw-fixation或者使用添加先验的方法可以应用于任何相机位姿，<strong>这通常用于第一帧</strong>。因此，对于其他帧的相机位姿，我们使用标准的迭代更新，对于第一帧，<span class="math inline">\(R_0\)</span>，我们使用更加方便的参数。我们不直接使用R0，而是使用左乘增量:</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-12-49-16.png"></p><p>其中，旋转向量<span class="math inline">\(\Delta \phi_0\)</span>被初始化为0，然后进行迭代更新。然而，旋转向量在<span class="math inline">\(||\Delta \phi_0||=\pi\)</span>的时候具有奇异，然而在优化的时候，提供的初值应该比较接近真值，即(<span class="math inline">\(||\Delta \phi_0||&lt;\pi\)</span>)，因此可以暂时不过分计较这个问题。</p><h2 id="处理gauge-freedom的不同方法">4.2. 处理<code>Gauge Freedom</code>的不同方法</h2><h3 id="gauge-fixation-approach">4.2.1. gauge fixation approach</h3><p>在整个优化过程中，测量固定包括固定第一帧位姿的位置和偏航角，这通过设置如下来实现:</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-22-05-05.png"></p><p>其中<span class="math inline">\(p_0^0\)</span>是第一帧相机的初始位姿，固定这些参数向量相当于将残差所计算的雅克比矩阵的对应的列置为0，即<span class="math inline">\(J_{p0}=0\)</span>，<span class="math inline">\(J_{\Delta 0z}=0\)</span></p><h3 id="gauge-prior-approach">4.2.2. gauge prior approach</h3><p>通过在目标函数(等式1)加入惩罚项:</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-22-12-36.png"></p><p>关于<span class="math inline">\(\Sigma_{0}^P\)</span>的选择在后面讨论</p><h3 id="free-gauge-approach">4.2.3. free gauge approach</h3><p>这个处理方法是让参数向量在优化中自由演化。为了求解这个奇异的Hessian矩阵，我们通过使用<code>伪逆</code>或者是<code>添加一些阻尼</code>(如LM算法)使得最小二乘问题可解。</p><p>三种方法优化迭代过程中参数空间路径的比较如图2所示</p><h1 id="三种处理方式的对比流程">5. 三种处理方式的对比流程</h1><h2 id="数据生成">5.1. 数据生成</h2><p>我们采用6自由度的轨迹，分别是<code>类正弦波</code>，<code>弧状的</code>，<code>矩形的</code>。考虑两种路标配置：</p><ul><li>平面的，3D点粗略的分布在几个平面上</li><li>随机的，3D点随机沿着轨迹生成</li></ul><p>图3展示了仿真:</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-22-35-01.png"></p><p>为了生成imu测量值，我们使用B样条拟合轨迹，然后采样出加速度和角速度。采样值会受到bias和额外添加的高斯白噪声影响，然后作为Imu测量值。</p><p>对于数据额测量，我们使用pinhole相机模型，将3D点投影到图像上，得到3D-2D的点对，然后也添加高斯白噪声。</p><h2 id="优化求解器">5.2. 优化求解器</h2><p>为了求解VI系统的状体估计问题，使用gogle的Ceres求解器，采用LM算法。然后实现了上面所述的3种对gauge freedoom的处理方式。对于每条轨迹，我们沿着轨迹采样一些关键帧。我们的参数空间包含了这些关键帧的状态(如位置、旋转、和速度)，以及3D点的位置，而初始状态被随机打乱</p><h2 id="评估">5.3. 评估</h2><ol type="1"><li><p>准确率:</p><p>为了评估<code>状态估计值</code>的准确率，我们首先计算了将估计值对齐到真值的变换，这个变换从所有轨迹的第一帧开始计算，这个变换具有4自由度(也就是上面提到的平移和绕重力方向矢量的旋转)。</p><p>对齐之后，我们计算所有关键帧的均方差根(RMSE)，特别的，我们对位置和速度误差使用欧几里得距离来计算。</p><p>对于旋转估计值，我们首先计算估计值和真值的相对旋转量(轴角形式表示)，然后使用相对旋转的角度作为旋转误差。</p></li><li><p>计算效率:</p><p>为了评估算力消耗，我们记录了求解器的收敛的时间和迭代次数。我们使用每种配置(如轨迹和3D点的结合)，进行50次试验，计算平均时间和精度指标</p></li><li><p>协方差:</p><p>我们同样比较由优化算法产生的协方差，这些协方差对active SLAM等应用有重要意义。</p><p>参数估计值的协方差由Hessian矩阵的逆确定。(对于<code>free gauge approach</code>，使用摩尔-彭罗斯伪逆，因为Hessian是奇异的)</p></li></ol><h1 id="对比结果研究">6. 对比结果研究</h1><h2 id="gauge-prior-选择恰当的先验权重">6.1. <code>Gauge Prior</code>: 选择恰当的先验权重</h2><p>在比较3种方法之前，对于<code>Gauge Prior Apporach</code>，首先需要选择先验协方差<span class="math inline">\(\Sigma_0^P\)</span>。</p><p>一种通用的选择是<span class="math inline">\(\Sigma_0^P=\sigma_0^PI\)</span>，也就是(式11)中的先验变成<span class="math inline">\(||r_0^P||_{\Sigma_{0}^P}^2=w^P||r_0^P||^2\)</span>，其中<span class="math inline">\(w^P=\frac{1}{\sigma_0^2}\)</span></p><p>我们测试了大范围的先验权重<span class="math inline">\(w^P\)</span>，最后得到的结果都是相似的。</p><p>需要注意的是，<span class="math inline">\(w^P=0\)</span>的本质是第三种方法<code>free gauge approach</code>，而<span class="math inline">\(w^P \rightarrow \infin\)</span>对应的是第一种方法<code>gauge fixation approach</code></p><h3 id="accuracy">6.1.1. Accuracy</h3><p>图4展示了随着先验权重变化，RMSE的变化。</p><p>可以看出，不同先验权值的估计误差非常相似(注意纵轴上的数字)。虽然对于轨迹和三维点的不同配置没有明确的最优先验权值，但当权值增加到一定的阈值以上时，RMSE稳定在一个值上，如图4则是500</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-23-03-45.png"></p><h3 id="computational-cost">6.1.2. Computational Cost</h3><p>图5展示了不同先验权重的计算代价，与图4相似，当先验权值大于一定值时，迭代次数和收敛时间趋于稳定。</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-23-09-57.png"></p><p>有趣的是，当先前的权重从0增加到稳定的阈值时，在计算时间上有一个峰值，对于所有配置都可以观察到相同的行为。</p><p>为了详细研究这一行为，我们在图6中绘制了几个先验权值的每次迭代的平均重投影误差的先验误差，</p><ul><li>位置先验误差是第一个位置的当前估计值与其初始值之间的欧氏距离</li><li>偏航先验误差是第一个旋转的当前估计相对于其初始值的相对旋转的z分量</li><li>平均重投影误差为所有关键帧中观察到的三维点的个数所平均得到的总视觉残差</li></ul><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-23-10-11.png"></p><p>对于非常大的先验权重(<span class="math inline">\(10^8\)</span>)，随着先验误差减少至0，算法同时也减少了重投影误差。</p><p>相比之下，对于较小的先验权值(如50-500)，优化算法在前两次迭代中减少了重投影误差，但代价是增加了先验误差，然后，优化算法进行多次迭代，(沿轨道移动)，对先验误差进行微调，同时保持重投影误差较小，因此计算时间增加。</p><h3 id="讨论">6.1.3. 讨论</h3><p>对于不同的先验权值，解的精度变化不明显时(如图4)，需要选择适当的先验权重来保持较低的算力消耗(图5).</p><p>极大的权值被丢弃，因为它们有时会使优化变得不稳定，对于不同的配置(轨迹和3D点的组合得到各种配置)，我们观察到类似的行为。因此，在接下来的部分，对于<code>gauge prior approach</code>，我们将使用合适的先验权重(如<span class="math inline">\(10^5\)</span>)。</p><h2 id="准确度和计算量">6.2. 准确度和计算量</h2><p>我们比较了三种方法在六种模拟轨迹(正弦、圆弧和矩形)和三维点(平面和随机)组合上的性能。</p><p>我们优化了使用不同扰动来初始化的目标函数，然后观察到结果都是相似的。所选取的扰动如下:</p><ul><li>真值位置使用5cm的向量进行扰动(对于整条轨迹就是5m)</li><li>旋转量使用随机旋转6度进行扰动</li><li>速度使用均匀分布随机扰动[-0.05,0.05]m/s ，(速度均值是2m/s)</li><li>3D点的位置采用均匀随机变量[-7.5,7.5]cm来进行扰动</li></ul><p>表二列出了50次试验的平均RMSE</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-07-09-59-13.png"></p><p>我们省略了<code>gauge prior approach</code>的结果，因为它们与<code>gauge fixation approach</code>在小数点后8位以内的结果相同。</p><p>可以看到，在<code>gauge fixation approach</code>和<code>free gauge approach</code>之间仅有很小的差异。</p><p>收敛时间和迭代次数如图7所示</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-07-10-04-19.png"></p><p><code>gauge prior approach</code>和<code>gauge fixation approach</code>的计算量大体相同，而第三种方法即<code>free gauge approach</code>比前两者稍微更快一些。</p><p>具体来说，除了具有随机三维点的正弦轨迹外，<code>free gauge approach</code>的迭代次数较少，(总体)收敛时间也较短。</p><p>有一点需要注意的是: <code>gauge fixation approach</code>由于优化中变量的数量较少，因此每次迭代花费的时间最少</p><h2 id="小结">6.3. 小结</h2><ul><li>这三种方法的精确度几乎相同</li><li><code>gauge prior approach</code>，需要选择合适的先验权重来避免计算量的增大</li><li>如果选择合适的先验权重，那么<code>gauge prior approach</code>将会与<code>gauge fixation approach</code>具有几乎一致的性能表现(精确度和计算量)</li><li><code>free gauge approach</code>比其他两种方法稍微快一些，因为它只需更少的迭代次数即可收敛</li></ul><p>虽然可以对不可观测的DoFs进行固定(即<code>gauge fixation approach</code>)(回想一下，我们使用了一个定制的参数化方法(9)来固定偏航角)，<strong>但是<code>free gauge approach</code>有一个额外的优点，那就是它是通用的</strong></p><h1 id="真实世界数据集测试">7. 真实世界数据集测试</h1><p>我们使用EuRoC MAV数据集的两个序列进行了与前面仿真环境相同的实验比较: Machine Hall 1 (MH1) 和 Vicon Room 1 (VI1).</p><p>我们使用 semi-direct visual odometry algorithm (SVO)来提供优化问题中参数的初始值，并且使用双目配置的SVO来消除尺度模糊性。对于bias，则直接使用数据集中附带的真值。</p><p>评估的方法与上面仿真环境下的一样，需要注意的是: <strong>我们并没有在完整的轨迹上运行优化，而是在更短的段上运行，这足以说明三种方法的不同之处</strong></p><p>三种不同方法的计算成本如图11所示</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-07-10-19-17.png"></p><p>准确率由表3展示: 这三种方法都有相似的估计误差</p><p><img src="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-07-10-19-58.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;on-the-comparison-of-gauge-freedom-handling-in-optimization-based-visual-inertial-state-estimation&quot;&gt;1. On the Comparison of Gauge Fr
      
    
    </summary>
    
    
      <category term="SLAM代码课程" scheme="http://yoursite.com/categories/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>VI中的几种自由度处理方法的性能对比</title>
    <link href="http://yoursite.com/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</id>
    <published>2020-04-06T02:01:39.000Z</published>
    <updated>2020-04-07T07:55:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="on-the-comparison-of-gauge-freedom-handling-in-optimization-based-visual-inertial-state-estimation">1. On the Comparison of Gauge Freedom Handling in Optimization-based Visual-Inertial State Estimation</h1><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-03-24.png"></p><h1 id="摘要">2. 摘要</h1><p>VI系统中有4个不可观测自由度，绕重力方向的旋转和平移(在本文中称为<span class="math inline">\(gauge~freedom\)</span>)，以及剩下一些可观的自由度，在求解过程中需要进行特殊的处理。 文章对比了以下3种处理方法:</p><ul><li>gauge fixation: 设置不可观测的状态为某个固定的值</li><li>gauge prior: 为某个状态设置先验</li><li>free gauge: 让状态在优化过程中自由演化，优化完成再进行处理</li></ul><h1 id="vi问题">3. VI问题</h1><p>视觉-惯性状态估计的问题包括对摄像机-惯性组合传感器(IMU)的运动和传感器在场景中运动时摄像机看到的三维地标位置的推断。</p><p>通过收集视觉测量方程(图像点)和惯性测量(加速度计和陀螺仪)，问题可写成非线性最小二乘，目标是最小化下面的方程:</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-19-44.png"></p><p>其中</p><ul><li><span class="math inline">\(||r||_\Sigma^2=r^T\Sigma^{-1}r\)</span>是残差向量<span class="math inline">\(r\)</span>的马氏距离</li><li><span class="math inline">\(\Sigma\)</span>是测量值的协方差矩阵，作为权重</li><li>这个cost func 可以作为 "full smoothing"或者"fixed-lag smooth"方法</li></ul><p>视觉项由图像观测点<span class="math inline">\(x_ij\)</span>的重投影误差组成，惯性项包括惯性测量值与IMU轨迹模型预测值(预积分)之间的误差。</p><p>问题求解的状态向量如下:</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-30-00.png"></p><p>包括摄像机运动参数(外参和线速度)和3D场景(地标)。</p><p>加速度计和陀螺仪的bias通常施加在IMU坐标系中，因此不受坐标系固定的影响，因此，我们排除bias，并假设IMU的测量已经纠正。</p><h2 id="解的歧义性和几何等价">3.1. 解的歧义性和几何等价</h2><p>对于VI系统状态估计问题，很重要的一点是，对参数<span class="math inline">\(\theta\)</span>(或者说状态)给定特殊的变换<span class="math inline">\(g(\theta)\)</span>，最终的目标函数(cost func)<span class="math inline">\(J(\theta)\)</span>不变，即:</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-36-12.png"></p><p>特别的，变换<span class="math inline">\(g()\)</span>可以用齐次矩阵的形式表达:</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-36-48.png"></p><p>这是一个4自由度的变换，其中:</p><ul><li><span class="math inline">\(t \in \R^3\)</span>是任意的平移</li><li>旋转<span class="math inline">\(R_z=\exp (\alpha e_z)\)</span>是绕重力方向轴<span class="math inline">\(e_z=(0,0,1)^T\)</span>的任意yaw角<span class="math inline">\(\alpha \in (-\pi,\pi)\)</span>所产生的旋转矩阵</li><li>为了简化表达，使用<span class="math inline">\(Exp(\theta)=\exp(\theta^\wedge)\)</span>来表示这个变换</li></ul><p>通过对状态应用上面的变换<span class="math inline">\(g(\theta)\)</span>，将得到新的状态<span class="math inline">\(\theta&#39; \equiv {p_i&#39;,R_i&#39;,v_i&#39;,X_j&#39;}\)</span></p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-42-52.png"></p><p><strong>对于<span class="math inline">\(\theta\)</span>和<span class="math inline">\(\theta&#39;\)</span>，它们是几何等价的，它们产生相同的误差，即，对于目标函数<span class="math inline">\(J(\theta)\)</span>，它们最终得到的值是一样的。</strong></p><p>作为不变性的结果，参数空间<span class="math inline">\(\mathcal{M}\)</span>可以分解成几何等价重构的不相交集合(即使用基来表示)，这些几何可以称为<span class="math inline">\(orbit\)</span>或者<span class="math inline">\(leaf\)</span></p><p>于是，关于<span class="math inline">\(\theta\)</span>的<span class="math inline">\(orbit\)</span>可以如下表示:</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-48-34.png"></p><p>其中,</p><ul><li><span class="math inline">\(\mathcal{G}\)</span>是<span class="math inline">\(g()\)</span>变换的群，注意到目标函数在每一个<span class="math inline">\(orbit\)</span>上都是常数(意思是存在变换<span class="math inline">\(g()\)</span>，都不会改变目标函数的值)</li></ul><p>不变性的主要结果是没有一个特定的解，原因是有无穷多个解可以使得目标函数达到同样的最小值，</p><p>如下图2: <span class="math inline">\(orbit\)</span>上的所有状态都可以达到同样的最小值(对于目标函数而言)</p><p>因此，VI状态估计问题具有不确定或者说不可观测的状态: 没有足够的方程来完全指定一个唯一解。</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-55-37.png"></p><p>上面是三种处理方法关于参数向量维度的对比:</p><ul><li>总的参数<span class="math inline">\(n=9N+3K\)</span>，N是相机节点数，K是路标数</li></ul><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-55-48.png"></p><h2 id="附加约束指定一个gauge">3.2. 附加约束:指定一个Gauge</h2><p>用附加约束完成(1)的处理</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-10-58-58.png"></p><p>这会产生一个独特的解，称为指定一个<span class="math inline">\(gauge\)</span>，C</p><p>换句话说，就是上面的(等式7)，选择了一个有代表性的<span class="math inline">\(orbit\)</span>，用来消除等价中的不确定性，在VI系统中，这是通过指定3D的参考坐标系来实现的。</p><p>举例: 选择包含第0帧的相机（固定其位姿为position={0,0,0},yaw=0）作为参考坐标系。这些约束指定了一个唯一的转换，因此，这个独特的解就是<span class="math inline">\(\mathcal{C}\)</span>和参数空间<span class="math inline">\(\mathcal{M}_\theta\)</span>的并集，即:</p><p><span class="math display">\[    \theta_C=\mathcal{C}\cap \mathcal{M}_\theta\]</span></p><p>那么<span class="math inline">\(gauge\)</span>，C，与轨道<span class="math inline">\(orbit\)</span>也就是<span class="math inline">\(\mathcal{M}_\theta\)</span>是横断的，因此，得到的解<span class="math inline">\(\theta_C\)</span>是唯一的</p><h1 id="处理gauge">4. 处理Gauge</h1><p>从优化的角度来看，使用高斯牛顿来对上面提到的目标函数进行求解会有一些困难，即使我们使用所有元素的最小参数化状态参数向量θ，目标函数中的海森矩阵(用于参数更新的<span class="math inline">\(H\Delta x\)</span>=b)，由于存在不可观测的自由度，因此是奇异的。</p><p>更加具体的说就是，它是一个秩亏矩阵，rank缺了4，恰恰对应了变换<span class="math inline">\(g()\)</span>中的4个自由度。</p><p>上面的Table 1 列出了3种常用的处理方法，其中，</p><ul><li>(gauge fixation approach)是<strong>在一个较小的参数空间中进行优化</strong>，在这个空间中没有不可观测的状态，因此Hessian是可逆的，这本质上强制了解的硬约束</li><li>(gauge prior approach)是<strong>通过附加惩罚</strong>(来产生一个可逆的Hessian)来增强目标函数，以使解决方案以一种软的方式满足某些约束</li><li>(free gauge approach)使用<strong>H的伪逆</strong>，来隐式地为唯一解决方案提供额外的约束(用最小范数更新参数)</li></ul><p>前两种策略需要特定于VI问题的知识(需要约束的状态)，而最后一种策略是通用的</p><h2 id="rotation-parametrization-for-gauge-fixation-or-prior">4.1. Rotation Parametrization for Gauge Fixation or Prior</h2><p>使用<code>gauge fixation</code>和<code>gauge prior</code>方法存在一个问题就是，固定相机位姿的1自由度yaw旋转角并不直接。</p><p>在使用求解器(如高斯牛顿、LM)迭代时，标准的更新旋转量的方法是:</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-11-38-19.png"></p><p>其中，q代表第q次迭代</p><p>通过设置<span class="math inline">\(\delta \phi^q\)</span>中关于<span class="math inline">\(z\)</span>的元素为0，就可以对<span class="math inline">\(R^q\)</span>中的yaw角进行固定，然而，如果连接几次这样的更新，如<span class="math inline">\(R^Q=\prod_{q=0}^{Q-1} Exp(\delta \phi ^q)R^0\)</span>，即相当于经过多次更新之后，并不能把<span class="math inline">\(R^Q\)</span>的yaw角固定成与<span class="math inline">\(R^0\)</span>的一致，测试代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eigen3/Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eigen3/Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sophus/so3.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Eigen::Matrix3d  R= Eigen::Matrix3d::Identity();</span><br><span class="line">    <span class="function">Sophus::SO3d <span class="title">R_n</span><span class="params">(R)</span></span>;</span><br><span class="line">    R_n= Sophus::SO3d::<span class="built_in">exp</span>(Eigen::Vector3d(<span class="number">0.3</span>,<span class="number">0.1</span>,<span class="number">0</span>))*R_n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"First :"</span>&lt;&lt;R_n.<span class="built_in">log</span>().transpose()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    R_n= Sophus::SO3d::<span class="built_in">exp</span>(Eigen::Vector3d(<span class="number">0.1</span>,<span class="number">0.2</span>,<span class="number">0</span>))*R_n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Second :"</span>&lt;&lt;R_n.<span class="built_in">log</span>().transpose()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    R_n= Sophus::SO3d::<span class="built_in">exp</span>(Eigen::Vector3d(<span class="number">0.5</span>,<span class="number">0.1</span>,<span class="number">0</span>))*R_n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Third :"</span>&lt;&lt;R_n.<span class="built_in">log</span>().transpose()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">First :   0.3 0.1   0</span><br><span class="line">Second :  0.399579    0.29916 -0.0251046</span><br><span class="line">Third : 0.896385  0.404603 0.0308449</span><br></pre></td></tr></table></figure><p>尽管使用yaw-fixation或者使用添加先验的方法可以应用于任何相机位姿，<strong>这通常用于第一帧</strong>。因此，对于其他帧的相机位姿，我们使用标准的迭代更新，对于第一帧，<span class="math inline">\(R_0\)</span>，我们使用更加方便的参数。我们不直接使用R0，而是使用左乘增量:</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-12-49-16.png"></p><p>其中，旋转向量<span class="math inline">\(\Delta \phi_0\)</span>被初始化为0，然后进行迭代更新。然而，旋转向量在<span class="math inline">\(||\Delta \phi_0||=\pi\)</span>的时候具有奇异，然而在优化的时候，提供的初值应该比较接近真值，即(<span class="math inline">\(||\Delta \phi_0||&lt;\pi\)</span>)，因此可以暂时不过分计较这个问题。</p><h2 id="处理gauge-freedom的不同方法">4.2. 处理<code>Gauge Freedom</code>的不同方法</h2><h3 id="gauge-fixation-approach">4.2.1. gauge fixation approach</h3><p>在整个优化过程中，测量固定包括固定第一帧位姿的位置和偏航角，这通过设置如下来实现:</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-22-05-05.png"></p><p>其中<span class="math inline">\(p_0^0\)</span>是第一帧相机的初始位姿，固定这些参数向量相当于将残差所计算的雅克比矩阵的对应的列置为0，即<span class="math inline">\(J_{p0}=0\)</span>，<span class="math inline">\(J_{\Delta 0z}=0\)</span></p><h3 id="gauge-prior-approach">4.2.2. gauge prior approach</h3><p>通过在目标函数(等式1)加入惩罚项:</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-22-12-36.png"></p><p>关于<span class="math inline">\(\Sigma_{0}^P\)</span>的选择在后面讨论</p><h3 id="free-gauge-approach">4.2.3. free gauge approach</h3><p>这个处理方法是让参数向量在优化中自由演化。为了求解这个奇异的Hessian矩阵，我们通过使用<code>伪逆</code>或者是<code>添加一些阻尼</code>(如LM算法)使得最小二乘问题可解。</p><p>三种方法优化迭代过程中参数空间路径的比较如图2所示</p><h1 id="三种处理方式的对比流程">5. 三种处理方式的对比流程</h1><h2 id="数据生成">5.1. 数据生成</h2><p>我们采用6自由度的轨迹，分别是<code>类正弦波</code>，<code>弧状的</code>，<code>矩形的</code>。考虑两种路标配置：</p><ul><li>平面的，3D点粗略的分布在几个平面上</li><li>随机的，3D点随机沿着轨迹生成</li></ul><p>图3展示了仿真:</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-22-35-01.png"></p><p>为了生成imu测量值，我们使用B样条拟合轨迹，然后采样出加速度和角速度。采样值会受到bias和额外添加的高斯白噪声影响，然后作为Imu测量值。</p><p>对于数据额测量，我们使用pinhole相机模型，将3D点投影到图像上，得到3D-2D的点对，然后也添加高斯白噪声。</p><h2 id="优化求解器">5.2. 优化求解器</h2><p>为了求解VI系统的状体估计问题，使用gogle的Ceres求解器，采用LM算法。然后实现了上面所述的3种对gauge freedoom的处理方式。对于每条轨迹，我们沿着轨迹采样一些关键帧。我们的参数空间包含了这些关键帧的状态(如位置、旋转、和速度)，以及3D点的位置，而初始状态被随机打乱</p><h2 id="评估">5.3. 评估</h2><ol type="1"><li><p>准确率:</p><p>为了评估<code>状态估计值</code>的准确率，我们首先计算了将估计值对齐到真值的变换，这个变换从所有轨迹的第一帧开始计算，这个变换具有4自由度(也就是上面提到的平移和绕重力方向矢量的旋转)。</p><p>对齐之后，我们计算所有关键帧的均方差根(RMSE)，特别的，我们对位置和速度误差使用欧几里得距离来计算。</p><p>对于旋转估计值，我们首先计算估计值和真值的相对旋转量(轴角形式表示)，然后使用相对旋转的角度作为旋转误差。</p></li><li><p>计算效率:</p><p>为了评估算力消耗，我们记录了求解器的收敛的时间和迭代次数。我们使用每种配置(如轨迹和3D点的结合)，进行50次试验，计算平均时间和精度指标</p></li><li><p>协方差:</p><p>我们同样比较由优化算法产生的协方差，这些协方差对active SLAM等应用有重要意义。</p><p>参数估计值的协方差由Hessian矩阵的逆确定。(对于<code>free gauge approach</code>，使用摩尔-彭罗斯伪逆，因为Hessian是奇异的)</p></li></ol><h1 id="对比结果研究">6. 对比结果研究</h1><h2 id="gauge-prior-选择恰当的先验权重">6.1. <code>Gauge Prior</code>: 选择恰当的先验权重</h2><p>在比较3种方法之前，对于<code>Gauge Prior Apporach</code>，首先需要选择先验协方差<span class="math inline">\(\Sigma_0^P\)</span>。</p><p>一种通用的选择是<span class="math inline">\(\Sigma_0^P=\sigma_0^PI\)</span>，也就是(式11)中的先验变成<span class="math inline">\(||r_0^P||_{\Sigma_{0}^P}^2=w^P||r_0^P||^2\)</span>，其中<span class="math inline">\(w^P=\frac{1}{\sigma_0^2}\)</span></p><p>我们测试了大范围的先验权重<span class="math inline">\(w^P\)</span>，最后得到的结果都是相似的。</p><p>需要注意的是，<span class="math inline">\(w^P=0\)</span>的本质是第三种方法<code>free gauge approach</code>，而<span class="math inline">\(w^P \rightarrow \infin\)</span>对应的是第一种方法<code>gauge fixation approach</code></p><h3 id="accuracy">6.1.1. Accuracy</h3><p>图4展示了随着先验权重变化，RMSE的变化。</p><p>可以看出，不同先验权值的估计误差非常相似(注意纵轴上的数字)。虽然对于轨迹和三维点的不同配置没有明确的最优先验权值，但当权值增加到一定的阈值以上时，RMSE稳定在一个值上，如图4则是500</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-23-03-45.png"></p><h3 id="computational-cost">6.1.2. Computational Cost</h3><p>图5展示了不同先验权重的计算代价，与图4相似，当先验权值大于一定值时，迭代次数和收敛时间趋于稳定。</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-23-09-57.png"></p><p>有趣的是，当先前的权重从0增加到稳定的阈值时，在计算时间上有一个峰值，对于所有配置都可以观察到相同的行为。</p><p>为了详细研究这一行为，我们在图6中绘制了几个先验权值的每次迭代的平均重投影误差的先验误差，</p><ul><li>位置先验误差是第一个位置的当前估计值与其初始值之间的欧氏距离</li><li>偏航先验误差是第一个旋转的当前估计相对于其初始值的相对旋转的z分量</li><li>平均重投影误差为所有关键帧中观察到的三维点的个数所平均得到的总视觉残差</li></ul><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-06-23-10-11.png"></p><p>对于非常大的先验权重(<span class="math inline">\(10^8\)</span>)，随着先验误差减少至0，算法同时也减少了重投影误差。</p><p>相比之下，对于较小的先验权值(如50-500)，优化算法在前两次迭代中减少了重投影误差，但代价是增加了先验误差，然后，优化算法进行多次迭代，(沿轨道移动)，对先验误差进行微调，同时保持重投影误差较小，因此计算时间增加。</p><h3 id="讨论">6.1.3. 讨论</h3><p>对于不同的先验权值，解的精度变化不明显时(如图4)，需要选择适当的先验权重来保持较低的算力消耗(图5).</p><p>极大的权值被丢弃，因为它们有时会使优化变得不稳定，对于不同的配置(轨迹和3D点的组合得到各种配置)，我们观察到类似的行为。因此，在接下来的部分，对于<code>gauge prior approach</code>，我们将使用合适的先验权重(如<span class="math inline">\(10^5\)</span>)。</p><h2 id="准确度和计算量">6.2. 准确度和计算量</h2><p>我们比较了三种方法在六种模拟轨迹(正弦、圆弧和矩形)和三维点(平面和随机)组合上的性能。</p><p>我们优化了使用不同扰动来初始化的目标函数，然后观察到结果都是相似的。所选取的扰动如下:</p><ul><li>真值位置使用5cm的向量进行扰动(对于整条轨迹就是5m)</li><li>旋转量使用随机旋转6度进行扰动</li><li>速度使用均匀分布随机扰动[-0.05,0.05]m/s ，(速度均值是2m/s)</li><li>3D点的位置采用均匀随机变量[-7.5,7.5]cm来进行扰动</li></ul><p>表二列出了50次试验的平均RMSE</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-07-09-59-13.png"></p><p>我们省略了<code>gauge prior approach</code>的结果，因为它们与<code>gauge fixation approach</code>在小数点后8位以内的结果相同。</p><p>可以看到，在<code>gauge fixation approach</code>和<code>free gauge approach</code>之间仅有很小的差异。</p><p>收敛时间和迭代次数如图7所示</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-07-10-04-19.png"></p><p><code>gauge prior approach</code>和<code>gauge fixation approach</code>的计算量大体相同，而第三种方法即<code>free gauge approach</code>比前两者稍微更快一些。</p><p>具体来说，除了具有随机三维点的正弦轨迹外，<code>free gauge approach</code>的迭代次数较少，(总体)收敛时间也较短。</p><p>有一点需要注意的是: <code>gauge fixation approach</code>由于优化中变量的数量较少，因此每次迭代花费的时间最少</p><h2 id="小结">6.3. 小结</h2><ul><li>这三种方法的精确度几乎相同</li><li><code>gauge prior approach</code>，需要选择合适的先验权重来避免计算量的增大</li><li>如果选择合适的先验权重，那么<code>gauge prior approach</code>将会与<code>gauge fixation approach</code>具有几乎一致的性能表现(精确度和计算量)</li><li><code>free gauge approach</code>比其他两种方法稍微快一些，因为它只需更少的迭代次数即可收敛</li></ul><p>虽然可以对不可观测的DoFs进行固定(即<code>gauge fixation approach</code>)(回想一下，我们使用了一个定制的参数化方法(9)来固定偏航角)，<strong>但是<code>free gauge approach</code>有一个额外的优点，那就是它是通用的</strong></p><h1 id="真实世界数据集测试">7. 真实世界数据集测试</h1><p>我们使用EuRoC MAV数据集的两个序列进行了与前面仿真环境相同的实验比较: Machine Hall 1 (MH1) 和 Vicon Room 1 (VI1).</p><p>我们使用 semi-direct visual odometry algorithm (SVO)来提供优化问题中参数的初始值，并且使用双目配置的SVO来消除尺度模糊性。对于bias，则直接使用数据集中附带的真值。</p><p>评估的方法与上面仿真环境下的一样，需要注意的是: <strong>我们并没有在完整的轨迹上运行优化，而是在更短的段上运行，这足以说明三种方法的不同之处</strong></p><p>三种不同方法的计算成本如图11所示</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-07-10-19-17.png"></p><p>准确率由表3展示: 这三种方法都有相似的估计误差</p><p><img src="/2020/04/06/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/2020-04-07-10-19-58.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;on-the-comparison-of-gauge-freedom-handling-in-optimization-based-visual-inertial-state-estimation&quot;&gt;1. On the Comparison of Gauge Fr
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
